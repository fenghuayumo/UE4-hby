#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/DeferredShadingCommon.ush"
#include "../PositionReconstructionCommon.ush" 
#include "SurfelCommon.ush"

#ifdef FIND_MISS_SURFEL

#define VISUALIZE_SURFELS 1
#define VISUALIZE_SURFELS_AS_NORMALS 1
#define VISUALIZE_CELL_SURFEL_COUNT 0
#define USE_DIRECTIONAL_IRRADIANCE 0
#define VISUALIZE_IRRADIANCE 0
#define USE_GEOMETRIC_NORMALS 1
#define USE_DEBUG_OUT 1


RWByteAddressBuffer SurfelHashKeyBuf;
RWByteAddressBuffer SurfelHashValueBuf;
RWByteAddressBuffer CellIndexOffsetBuf;
RWByteAddressBuffer SurfelIndexBuf;
RWStructuredBuffer<SurfelVertexPacked> SurfelVertexBuf;
RWStructuredBuffer<float4> SurfelIrradianceBuf;

RWByteAddressBuffer SurfelMetaBuf;
RWStructuredBuffer<float4> SurfelSHBuf;
RWTexture2D<float4> RWDebugOutTex;
RWTexture2D<uint2> RWTileSurfelAllocTex;

Texture2D<float4>   NormalTexture;
Texture2D<float>    DepthTexture;
// Texture2D<float4>   BaseColorTexture;
// Texture2D<float4>   MetallicTexture;

SamplerState        PointClampSampler;
SamplerState        LinearClampSampler;
float4              ScaledViewSizeAndInvSize;

#include "SurfelGridHashMut.ush"

groupshared uint GSPxScoreLocPacked;


float3 tricolor_ramp(float3 a, float3 b, float3 c, float x) {
    x = saturate(x);

    #if 0
        float x2 = x * x;
        float x3 = x * x * x;
        float x4 = x2 * x2;

        float cw = 3*x2 - 2*x3;
        float aw = 1 - cw;
        float bw = 16*x4 - 32*x3 + 16*x2;
        float ws = aw + bw + cw;
        aw /= ws;
        bw /= ws;
        cw /= ws;
    #else
        const float lobe = pow(smoothstep(1, 0, 2 * abs(x - 0.5)), 2.5254);
        float aw = x < 0.5 ? 1 - lobe : 0;
        float bw = lobe;
        float cw = x > 0.5 ? 1 - lobe : 0;
    #endif

    return aw * a + bw * b + cw * c;
}

float3 cost_color_map(float x) {
    return tricolor_ramp(
        float3(0.05, 0.2, 1),
        float3(0.02, 1, 0.2),
        float3(1, 0.01, 0.1),
        x
    );
}

[numthreads(8, 8, 1)]
void FindMissSurfel(
    uint2 DispatchThreadID: SV_DispatchThreadID,
    uint GroupIndex: SV_GroupIndex,
    uint2 GroupID: SV_GroupID,
    uint2 GroupThreadID: SV_GroupThreadID)
{
    if( DispatchThreadID.x >=  View.ViewSizeAndInvSize.x || DispatchThreadID.y >= View.ViewSizeAndInvSize.y )
        return;   
    #if USE_DEBUG_OUT
        RWDebugOutTex[DispatchThreadID.xy] = 0.0.xxxx;
    #endif
    if (0 == GroupIndex)
    {
        GSPxScoreLocPacked = 0;
        RWTileSurfelAllocTex[GroupID] = uint2(0, 0);
    }
    GroupMemoryBarrierWithGroupSync();

    int2 PixelCoord = (DispatchThreadID.xy);
    uint Seed = hash_combine2(hash_combine2(PixelCoord.x, hash1(PixelCoord.y)), View.StateFrameIndex);

    float2 BufferUV = (PixelCoord + View.ViewRectMin.xy + 0.5f) * View.BufferSizeAndInvSize.zw;
    float2 InvBufferSize = View.BufferSizeAndInvSize.zw;
    float DeviceZ = DepthTexture.SampleLevel(PointClampSampler, BufferUV, 0).r;
    const bool bIsValidPixel = DeviceZ > 1e-3 && DeviceZ < 0.999;
    if ( !bIsValidPixel) return;
    float SceneDepth = ConvertFromDeviceZ(DeviceZ);
	float3 WorldPosition = ReconstructWorldPositionFromDepth(BufferUV, SceneDepth);
    float3 WorldNormal = normalize(DecodeNormal(NormalTexture.SampleLevel(LinearClampSampler, BufferUV, 0).xyz));

    SurfelGridHashEntry entry = SurfelHashLookupByGridCoord(GetSurfelGridCoordFromPos(WorldPosition / SURFEL_UNIT_SCALE ));
    const float2 GroupCenterOffset = float2(GroupThreadID) - 3.5;

    float PxScore = 1e10 / (1.0 + dot(GroupCenterOffset, GroupCenterOffset));

    uint CellIdx = 0xffffffff;

    if (entry.found) 
    {
        PxScore = 0.0;

        CellIdx = SurfelHashValueBuf.Load(sizeof(uint) * entry.idx);
        float3 SurfelColor = 0;//uint_id_to_color(CellIdx) * 0.3;

        // Calculate px score based on surrounding surfels
        uint2 SurfelIdxRange = CellIndexOffsetBuf.Load2(sizeof(uint) * CellIdx);
        const uint CellSurfelCount = SurfelIdxRange.y - SurfelIdxRange.x;

        // Hack: Make sure we're not iterating over tons of surfels out of bounds
        SurfelIdxRange.y = min(SurfelIdxRange.y, SurfelIdxRange.x + 128);

        float3 TotalColor = 0.0.xxx;
        float TotalWeight = 0.0;
        float ScoringTotalWeight = 0.0;
        uint UsefulSurfelCount = 0;

        for (uint idx = SurfelIdxRange.x; idx < SurfelIdxRange.y; ++idx) 
        {
            const uint SurfelIdx = SurfelIndexBuf.Load(sizeof(uint) * idx);

            SurfelVertex surfel = UnPackVertex(SurfelVertexBuf[SurfelIdx]);
            
            #if VISUALIZE_SURFELS && VISUALIZE_IRRADIANCE
            float4 SurfelIrradiancePacked = SurfelIrradianceBuf[SurfelIdx];
            SurfelColor = SurfelIrradiancePacked.xyz;
            #endif

            #if VISUALIZE_SURFELS && VISUALIZE_SURFELS_AS_NORMALS
                SurfelColor = surfel.Normal * 0.5 + 0.5;
            #endif

            const float3 PosOffset = (WorldPosition.xyz - surfel.Position.xyz) / SURFEL_UNIT_SCALE;;
            const float DirWeight = max(0.0, dot(surfel.Normal, WorldNormal));
            //const float DirWeight = pow(max(0.0, dot(surfel.Normal, Normal)), 2);
            //const float DirWeight = 1;
            //const float DirWeight = pow(max(0.0, 0.5 + 0.5 * dot(surfel.Normal, Normal)), 2);
            const float dist = length(PosOffset);
            const float mahalanobis_dist = length(PosOffset) * (1 + abs(dot( (PosOffset), surfel.Normal)) * SURFEL_NORMAL_DIRECTION_SQUISH);

            float Weight = smoothstep(
                SURFEL_RADIUS * RADIUS_OVERSCALE,
                0.0,
                mahalanobis_dist) * DirWeight;
            const float ScoringWeight = smoothstep(
                SURFEL_RADIUS,
                0.0,
                mahalanobis_dist) * DirWeight;

            UsefulSurfelCount += ScoringWeight > 1e-5  ? 1 : 0;

            //weight *= saturate(inverse_lerp(31.0, 128.0, SurfelIrradiancePacked.w));
            TotalWeight += Weight;
            ScoringTotalWeight += ScoringWeight;
            TotalColor += SurfelColor * Weight * (VISUALIZE_SURFELS ? (dist < 0.05 ? 1 : 0.1) : 1);
            // TotalColor += SurfelColor * 1.0/ CellSurfelCount;
        }

        TotalColor /= max(0.1, TotalWeight);

        #if VISUALIZE_CELL_SURFEL_COUNT
            TotalColor = cost_color_map(CellSurfelCount / 32.0);
        #endif

        if (CellSurfelCount > 128) 
            TotalColor = float3(0, 1, 0);

        //TotalColor = uint_id_to_color(CellIdx) * 0.3;
        //TotalColor = saturate(1.0 - length(WorldPosition.xyz));

        #if USE_DEBUG_OUT
            RWDebugOutTex[PixelCoord] = float4(TotalColor, 1);
        #endif

        if (CellSurfelCount >= 32 || UsefulSurfelCount > 2 || ScoringTotalWeight > 0.2) 
            return;

        PxScore = 1.0 / (1.0 + TotalWeight);
    } 
    else 
    {
        if (entry.vacant) 
        {
            //if (uint_to_u01_float(hash1_mut(Seed)) < 0.001) 
            {
                if (entry.acquire()) 
                {
                    SurfelMetaBuf.InterlockedAdd(0 * sizeof(uint), 1, CellIdx);
                    SurfelHashValueBuf.Store(entry.idx * sizeof(uint), CellIdx);
                } 
                else 
                {
                    // Allocating the cell
                    #if USE_DEBUG_OUT
                        RWDebugOutTex[PixelCoord] = float4(10, 0, 0, 1);
                    #endif
                    return;
                }
            }
        } 
        else 
        {
            // Too many conflicts; cannot insert a new entry.
            #if USE_DEBUG_OUT
                RWDebugOutTex[PixelCoord] = float4(10, 0, 10, 1);
            #endif
            return;
        }
    }

    // Execution only survives here if we would like to allocate a surfel in this tile
    uint PxScoreLocPacked = 0;
    float FarFactor = 20000.0 ;/// SURFEL_UNIT_SCALE;
    float PtDepth = length(WorldPosition - View.TranslatedWorldCameraOrigin);
    if (uint_to_u01_float(hash1_mut(Seed)) <  FarFactor / 64.0 * View.ViewSizeAndInvSize.z * View.ViewSizeAndInvSize.w)
    {
        PxScoreLocPacked = (asuint(PxScore) & (0xffffffff - 63)) | (GroupThreadID.y * 8 + GroupThreadID.x);
    }
    
    InterlockedMax(GSPxScoreLocPacked, PxScoreLocPacked);
    GroupMemoryBarrierWithGroupSync();

    if (GSPxScoreLocPacked == PxScoreLocPacked && PxScoreLocPacked != 0)
    {
        #if USE_DEBUG_OUT
            RWDebugOutTex[PixelCoord] = float4(10, 10, 0, 1);
        #endif
        RWTileSurfelAllocTex[GroupID] = uint2(PxScoreLocPacked, CellIdx);
    } 
    else 
    {
        #if USE_DEBUG_OUT
        RWDebugOutTex[PixelCoord] = float4(0, 0, 10, 1);
        #endif
    }
}

#endif

#ifdef ALLOCATE_SURFEL
// #include "SurfelGridHash.ush"

RWByteAddressBuffer SurfelMetaBuf;
Texture2D<uint2> TileSurfelAllocTex;
RWStructuredBuffer<SurfelVertexPacked> SurfelVertexBuf;

Texture2D<float4>   NormalTexture;
Texture2D<float>    DepthTexture;
Texture2D<float4>   BaseColorTexture;
Texture2D<float4>   MetallicTexture;

SamplerState        PointClampSampler;
SamplerState        LinearClampSampler;
uint2               TileSurfelAllocTexSize;

[numthreads(8, 8, 1)]
void AllocateSurfels(
    uint2 TilePixelCoord: SV_DispatchThreadID,
    uint2 GroupID: SV_GroupID,
    uint2 GroupThreadID: SV_GroupThreadID) 
{
    if( TilePixelCoord.x >= TileSurfelAllocTexSize.x || TilePixelCoord.y >= TileSurfelAllocTexSize.y)
        return;
    const uint2 TileSurfelAllocPacked = TileSurfelAllocTex[TilePixelCoord];
    if (TileSurfelAllocPacked.x == 0) 
        return;

    const uint PxScoreLocPacked = TileSurfelAllocPacked.x;
    const uint CellIdx = TileSurfelAllocPacked.y;

    const uint2 PixelCoord = TilePixelCoord * 8 + uint2(PxScoreLocPacked & 7, (PxScoreLocPacked >> 3) & 7);

    float2 BufferUV = (PixelCoord + View.ViewRectMin.xy + 0.5f) * View.BufferSizeAndInvSize.zw;
    float2 InvBufferSize = View.BufferSizeAndInvSize.zw;
    float DeviceZ = DepthTexture.SampleLevel(PointClampSampler, BufferUV, 0).r;
    const bool bIsValidPixel = DeviceZ > 1e-3;
    if ( !bIsValidPixel) return;
    float SceneDepth = ConvertFromDeviceZ(DeviceZ);
	float3 WorldPosition = ReconstructWorldPositionFromDepth(BufferUV, SceneDepth);
    float3 WorldNormal = normalize(DecodeNormal(NormalTexture.SampleLevel(LinearClampSampler, BufferUV, 0).xyz));

    float3 BaseColor = DecodeBaseColor(BaseColorTexture.SampleLevel(PointClampSampler, BufferUV, 0).rgb);
    float Metallic = MetallicTexture.SampleLevel(PointClampSampler, BufferUV, 0).r;
    float3 Albedo = BaseColor - BaseColor * Metallic;
    SurfelVertexPacked surfel = (SurfelVertexPacked)0;
    // TODO: proper packing
    surfel.data0 = float4(WorldPosition.xyz, PackNormal_11_10_11(WorldNormal));
    surfel.data1 = float4(Albedo, asfloat(PackUint16_16(PixelCoord)));
    uint SurfelIdx;
    SurfelMetaBuf.InterlockedAdd(1 * sizeof(uint), 1, SurfelIdx);

    SurfelVertexBuf[SurfelIdx] = surfel;
}

#endif