#pragma once


struct ReGIR_PackedReservoir
{
	uint4 HitGeometry;
	uint4 LightInfo;
};

// Code for managing reads/writes to reservoirs
RWStructuredBuffer<ReGIR_PackedReservoir> RWLightReservoirUAV;
uint3 GridCellDim;

RWStructuredBuffer<ReGIR_PackedReservoir> RWLightReservoirHistoryUAV;
StructuredBuffer<ReGIR_PackedReservoir> LightReservoirHistory;
// uint3 ReservoirHistoryBufferDim;

uint NumLightSlotsPerCell;
uint NumCandidatesPerLightSlot;
uint NumCandidatesPerCell;
float3 LightBoundMin;
float3 LightBoundMax;

uint ComputeReservoirAddress(int3 CellCoord, int Slice, uint3 BufferDim)
{
    uint Address =  CellCoord.z * BufferDim.x * BufferDim.y
        + CellCoord.y * BufferDim.x
        + CellCoord.x;
	uint CellIndex =  BufferDim.x * BufferDim.y * BufferDim.z * Slice + Address;

	return CellIndex * NumLightSlotsPerCell;
}

uint CalcCellLinearIndex(int3 CellCoord, int Slice)
{
	// uint Address =  CellCoord.z * GridCellDim.x * GridCellDim.y
    //     + CellCoord.y * GridCellDim.x
    //     + CellCoord.x;
	uint Index =  CellCoord.z * GridCellDim.x * GridCellDim.y
        + CellCoord.y * GridCellDim.x
        + CellCoord.x;
	return Index;
}

uint3 GetCellIndexFromPos(float3 WorldPos)
{
	float3 BdSize = LightBoundMax - LightBoundMin;
	float3 BdCenter = (LightBoundMax + LightBoundMin) * 0.5;
	float3 Offset = (WorldPos - LightBoundMin) / BdSize;
	uint3 Index = clamp(floor(Offset * GridCellDim), uint3(0,0,0), uint3(GridCellDim.x-1, GridCellDim.y-1, GridCellDim.z-1));
	return Index;
}

ReGIR_PackedReservoir ReadReservoirData(uint Address, int Slice)
{
	uint Offset = Slice * GridCellDim.x * GridCellDim.y * GridCellDim.z;
	return RWLightReservoirUAV[Address + Offset];
}

void WriteReservoirData(uint Address, int Slice, ReGIR_PackedReservoir Value)
{
	uint Offset = Slice * GridCellDim.x * GridCellDim.y * GridCellDim.z;
	RWLightReservoirUAV[Address + Offset] = Value;
}

ReGIR_PackedReservoir ReadReservoirHistoryData(uint Address, int Slice)
{
	uint Offset = Slice * GridCellDim.x * GridCellDim.y * GridCellDim.z;
	return LightReservoirHistory[Address + Offset];
}

void WriteReservoirHistoryData(uint Address, int Slice, ReGIR_PackedReservoir Value)
{
	uint Offset = Slice * GridCellDim.x * GridCellDim.y * GridCellDim.z;
	RWLightReservoirHistoryUAV[Address + Offset] = Value;
}

uint2 PackIrradiance(float3 Irradiance, float M)
{
	uint2 Packed = (uint2)0;

	// Note: Consider keeping Lumiance(Y) in full range
	Packed.x = f32tof16(Irradiance.x) | (f32tof16(Irradiance.y) << 16);
	Packed.y = f32tof16(Irradiance.z) | (f32tof16(M) << 16);
	return Packed;
}

void UnpackIrradiance(uint2 Irradiance, out float3 Unpacked, out float M)
{
	Unpacked.x = f16tof32(Irradiance.x & 0xffff);
	Unpacked.y = f16tof32(Irradiance.x >> 16);
	Unpacked.z = f16tof32(Irradiance.y & 0xffff);
	M          = f16tof32(Irradiance.y >> 16);
}

uint PackNormal(float3 Normal)
{
	float alpha = 0;
	if ((Normal.x != 0 || Normal.y != 0))
	{
		alpha = atan2(Normal.y, Normal.x);
	}
	return f32tof16(alpha) | (f32tof16(Normal.z) << 16);
}

float3 UnpackNormal(uint PackedNormal)
{
	float z = f16tof32(PackedNormal >> 16);
	float alpha = f16tof32(PackedNormal & 0xffff);
	float r = sqrt(abs(1 - z * z));
	return float3(cos(alpha) * r, sin(alpha) * r, z);
}


struct ReGIR_SampleRef
{
	float3 Position;
	float3 Normal;
	float3 Irradiance;
	uint   Valid;

	bool IsValid()
	{
		return Valid > 0;
	}

	static ReGIR_SampleRef Invalid()
	{
		ReGIR_SampleRef s = (ReGIR_SampleRef)0;
		s.Valid = 0;
		s.Irradiance = 0;
		
		s.Position = 0;
		s.Normal = 0;
		return s;
	}

	static ReGIR_SampleRef Create(float3 samPos, float3 samNormal, float3 Irradiance)
	{
		ReGIR_SampleRef s;
		s.Position = samPos;
		s.Normal = samNormal;
		s.Irradiance = Irradiance;
		s.Valid = 1;
		return s;
	}
};

// Use 24-bit unsigned float to enable extra precision and keep the reservior in a single 128-bit quantity
#define CUSTOM_FLOAT 1

// This structure represents a single light reservoir that stores the weights, the sample ref,
// and sample count (M). It can be stored into uint4 and loaded from uint4, except the weightSum field.
struct ReGIR_Reservoir
{
	static const uint MaxM = 0xffff;

	ReGIR_SampleRef sampleRef;
	float weightSum;
	float targetPdf;
	uint age; // how many frame 
	uint M;

	static ReGIR_Reservoir Empty()
	{
		ReGIR_Reservoir s;
		s.sampleRef = ReGIR_SampleRef::Invalid();
		s.targetPdf = 0;
		s.weightSum = 0;
		s.age = 0;
		s.M = 0;
		return s;
	}

	static ReGIR_Reservoir Load(ReGIR_PackedReservoir data)
	{
		ReGIR_Reservoir res;
		uint4 HitGeometry = data.HitGeometry;
		res.sampleRef.Position = asfloat(HitGeometry.xyz);
		res.sampleRef.Normal = UnpackNormal(HitGeometry.w);

		uint4 LightInfo = data.LightInfo;
		UnpackIrradiance(LightInfo.xy, res.sampleRef.Irradiance, res.M);
		res.sampleRef.Valid = res.M ;
		res.weightSum = asfloat(LightInfo.z );
		// res.targetPdf = asfloat(LightInfo.w);
		res.age = LightInfo.w & 0xff;

		// unsigned 24 bit floats
		// uint weightSum = (LightInfo.z & 0xffffff00);
		uint targetPdf = (LightInfo.w & 0xffffff00);
		res.targetPdf = asfloat(targetPdf >> 1);

		// Discard reservoirs that have Inf/NaN
		if (isinf(res.weightSum) || isnan(res.weightSum)) {
			res = Empty();
		}

		return res;
	}

	ReGIR_PackedReservoir Store()
	{
		ReGIR_PackedReservoir data;

		uint4 HitGeometry;
		HitGeometry.xyz = asuint(sampleRef.Position);
		HitGeometry.w = PackNormal(sampleRef.Normal);
		data.HitGeometry = HitGeometry;

		uint4 LightInfo;
		LightInfo.xy = PackIrradiance(sampleRef.Irradiance, M);
		LightInfo.z = asuint(weightSum);
		// LightInfo.w = asuint(targetPdf);

		const float RoundConst = 1.0f / float(1 << 18); // 1/(2^18) is the first bit unrepresented by the custom float)
		// float RoundedWeight = weightSum + weightSum * RoundConst;
		float RoundedPdf = targetPdf + targetPdf * RoundConst;
		//remove sign as values are guaranteed positive
		//uint uWeightSum = asuint(max(0.0, RoundedWeight)) << 1;
		uint uTargetPdf = asuint(max(0.0, RoundedPdf)) << 1;

		age = min(age, 255);
		//chop to 24 bits
		//uWeightSum = uWeightSum & 0xffffff00;
		uTargetPdf = uTargetPdf & 0xffffff00;
		LightInfo.w = (uTargetPdf) | (age & 0xff);

		data.LightInfo = LightInfo;
		
		return data;
	}

	void FinalizeResampling(float normalizationNumerator, float normalizationDenominator)
	{
		float denominator = targetPdf * normalizationDenominator;

		weightSum = (denominator == 0.0) ? 0.0 : (weightSum * normalizationNumerator) / denominator;
		// if( isinf(weightSum) || isnan(weightSum) )
		// {
		// 	weightSum = 0.0;
		// 	targetPdf = 0;
		// 	M = 0;
		// 	age = 0;
		// 	sampleRef.Valid = 0;
		// }
	}

	// Adds a new, non-reservoir light sample into this reservoir.
	// Algorithm (3) from the ReSTIR paper, Streaming RIS using weighted reservoir sampling.
	bool StreamSample(ReGIR_SampleRef newSampleRef, float random, float newTargetPdf, float invSourcePdf)
	{
		// What's the current weight
		float risWeight = newTargetPdf * invSourcePdf;

		// Add one sample to the counter
		M += 1;

		// Update the weight sum
		weightSum += risWeight;

		// Decide if we will randomly pick this sample
		bool selectSample = (random * weightSum < risWeight);

		// If we did select this sample, update the relevant data.
		// New samples don't have visibility or age information, we can skip that.
		if (selectSample)
		{
			sampleRef = newSampleRef;
			targetPdf = newTargetPdf;
		}

		return selectSample;
	}

	// Adds a reservoir with one sample into this reservoir.
	// Algorithm (4) from the ReSTIR paper, Combining the streams of multiple reservoirs.
	// Normalization - Equation (6) - is postponed until all reservoirs are combined.
	bool CombineReservoirs(ReGIR_Reservoir newReservoir, float random, float newTargetPdf)
	{
		// What's the current weight (times any prior-step RIS normalization factor)
		float risWeight = newTargetPdf * newReservoir.weightSum * newReservoir.M;

		// Our *effective* candidate pool is the sum of our candidates plus those of our neighbors
		M += newReservoir.M;

		// Update the weight sum
		weightSum += risWeight;

		// Decide if we will randomly pick this sample
		bool selectSample = (random * weightSum < risWeight);

		// If we did select this sample, update the relevant data
		if (selectSample)
		{
			sampleRef = newReservoir.sampleRef;
			targetPdf = newTargetPdf;
			age = newReservoir.age;
		}

		return selectSample;
	}
};
