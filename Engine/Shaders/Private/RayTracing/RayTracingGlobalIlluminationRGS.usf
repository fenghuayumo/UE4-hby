// Copyright Epic Games, Inc. All Rights Reserved.

#define USE_IES_TERM 0 // this shader doesn't bind the IES atlas, so disable the IES term from path tracer lights

#include "../Common.ush"
#include "../RectLight.ush"
//#include "../MonteCarlo.ush"
#include "../DeferredShadingCommon.ush"
#include "../ShadingModels.ush"
#include "../SceneTextureParameters.ush"
#include "RayTracingCommon.ush"
#include "RayTracingDeferredShadingCommon.ush"
#include "RayTracingHitGroupCommon.ush"

#include "RayTracingTimingCommon.ush"

// #define EXPLORE_DISTANCE_TYPE
#define LIGHT_GRID 1
#define LIGHT_TREE 2
#define LIGHT_CUT  3
#define LIGHT_UNIFROM 4

// #define LIGHT_SAMPLING_TYPE 1
#ifndef LIGHT_SAMPLING_TYPE
#define LIGHT_SAMPLING_TYPE 0
#endif

#if LIGHT_SAMPLING_TYPE == LIGHT_UNIFROM
#define UNIFORM_LIGHT_SELECTION
#endif
#if LIGHT_SAMPLING_TYPE == LIGHT_GRID
#define USE_PATH_TRACING_LIGHT_GRID 1
#else
#define USE_PATH_TRACING_LIGHT_GRID 0
#endif

#include "../PathTracing/Material/PathTracingMaterialSampling.ush"
#include "../PathTracing/Utilities/PathTracingRandomSequence.ush"
#include "../PathTracing/Light/PathTracingLightGrid.ush"
#include "../PathTracing/Light/PathTracingLightSampling.ush"

#include "../LightCut/LightTreeSampling.ush"

#define USE_PATHTRACING_MATERIALS 0

RaytracingAccelerationStructure TLAS;
RWTexture2D<float4> RWGlobalIlluminationUAV;
RWTexture2D<float2> RWGlobalIlluminationRayDistanceUAV;

uint SamplesPerPixel;
uint MaxBounces;
uint UpscaleFactor;
float MaxRayDistanceForGI;
float MaxRayDistanceForAO;
float MaxShadowDistance;
float NextEventEstimationSamples;
float DiffuseThreshold;
uint EvalSkyLight;
uint UseRussianRoulette;
uint UseFireflySuppression;
float MaxNormalBias;
uint RenderTileOffsetX;
uint RenderTileOffsetY;
uint AccumulateEmissive;

int AccumulateTime;
RWTexture2D<uint> CumulativeTime;

int DistanceType;
int LeafStartIndex;

int MaxCutNodes;
int CutShareGroupSize;
float ErrorLimit;
int UseApproximateCosineBound;
int InterleaveRate;


StructuredBuffer<int> LightCutBuffer;
StructuredBuffer<FLightNode> NodesBuffer;

StructuredBuffer<int> MeshLightCutBuffer;
StructuredBuffer<FLightNode> MeshLightNodesBuffer;
int 						 MeshLightLeafStartIndex;

StructuredBuffer<float3>       MeshLightVertexBuffer;
StructuredBuffer<uint>         MeshLightIndexBuffer;
StructuredBuffer<MeshLightInstanceTriangle>    MeshLightInstancePrimitiveBuffer;
StructuredBuffer<MeshLightInstance>   MeshLightInstanceBuffer;
uint 							NumLightTriangles;

#include "../ReGIR/ReservoirManagement.ush"
#include "../ReGIR/RandomNumberUtils.ush"

#if LIGHT_SAMPLING_TYPE > LIGHT_GRID
#define MESH_LIGHT_SAMPLING     1
#endif
// #define UNIFORM_MESHLIGHT_SAMPLING 1
void GenerateCosineNormalRay(
	float3 WorldPosition,
	float3 WorldNormal,
	float2 RandSample,
	out float3 RayOrigin,
	out float3 RayDirection,
	out float RayTMin,
	out float RayTMax,
	out float RayPdf
)
{
	// Perform cosine-hemispherical sampling and convert to world-space
	float4 Direction_Tangent = CosineSampleHemisphere(RandSample);
	float3 Direction_World = TangentToWorld(Direction_Tangent.xyz, WorldNormal);

	RayOrigin = WorldPosition;
	RayDirection = Direction_World;
	RayTMin = 0.01;
	RayTMax = max(MaxRayDistanceForGI, MaxRayDistanceForAO);
	RayPdf = Direction_Tangent.w;
}

bool SampleLightTree(
	float3 RandSample,
	float3 WorldPos,
	float3 WorldNormal,
	StructuredBuffer<FLightNode> LightNodes,
	int LeafStartIndex,
	int StartNodeID,
	uint PrimitiveLightingChannelMask,
	bool IsTransmissiveMaterial,
	out int OutLightId,
	out float3 OutDirection,
	out float  OutDistance,
	out float3 OutRadianceOverPdf,
	out float OutPdf)
{
	// set default values in case sampling fails
	OutLightId = -1;
	OutDirection = 0;
	OutDistance = 0;
	OutRadianceOverPdf = 0;
	OutPdf = 0;

	if (SceneLightCount == 0)
	{
		// no lights in the scene
		return false;
	}
	float LightPickPdf = 1.0;
	bool deadBranch = false;

	float InfinteLightCdfSum = 0;
	// float LightPickingCdf[4];
	// int LightCdfCount = min(SceneInfiniteLightCount, 4);
	for (uint LightIndex = 0; LightIndex < SceneInfiniteLightCount; ++LightIndex)
	{
		InfinteLightCdfSum += EstimateLight(LightIndex, WorldPos, WorldNormal, PrimitiveLightingChannelMask, IsTransmissiveMaterial);
		// LightPickingCdf[LightIndex] = InfinteLightCdfSum;
	}
	FLightNode RootNode = LightNodes[1];
	float BoundCenter = RootNode.BoundMin + RootNode.BoundMax;
	float3 ToNode = (BoundCenter - WorldPos);
	float ToDist = length(ToNode);
	float NodeLightingEstimate =  RootNode.Intensity * dot(ToNode / ToDist, WorldNormal);// / ( ToDist * ToDist);

	// float pInfinite = float(SceneInfiniteLightCount) /
    //                       float(SceneInfiniteLightCount + (SceneLightCount ==  SceneInfiniteLightCount? 0 : 1));
	float pInfinite = InfinteLightCdfSum / ( InfinteLightCdfSum + NodeLightingEstimate) ;
	if (RandSample.x < pInfinite) 
	{
		// Sample infinite lights with uniform probability
		RandSample.x /= pInfinite;
		int index = min(int(floor(RandSample.x * SceneInfiniteLightCount)), SceneInfiniteLightCount - 1);
		LightPickPdf = pInfinite / SceneInfiniteLightCount;
		OutLightId = index;
	}
	else
	{
		deadBranch = TraverseLightTree(WorldPos, WorldNormal, StartNodeID, LightNodes, 
				LeafStartIndex, UseApproximateCosineBound, DistanceType,
				RandSample.x ,LightPickPdf,OutLightId );
		LightPickPdf *= 1- pInfinite;
	}
	if( deadBranch )
		return false;

	FLightSample Result = SampleLight(OutLightId, RandSample.yz, WorldPos, WorldNormal);
	OutDirection = Result.Direction;
	OutDistance = Result.Distance;
	OutRadianceOverPdf = Result.RadianceOverPdf / LightPickPdf;
	OutPdf = Result.Pdf * LightPickPdf;

	return true;
}

bool SampleInfiniteLight(
	float3 RandSample,
	float3 WorldPos,
	float3 WorldNormal,
	uint PrimitiveLightingChannelMask,
	bool IsTransmissiveMaterial,
	out int OutLightId,
	out float3 OutDirection,
	out float  OutDistance,
	out float3 OutRadianceOverPdf,
	out float OutPdf
)
{
	if( SceneInfiniteLightCount > 0)
	{
		float LightPickPdf = 1.0;
		int index = min(int(floor(RandSample.x * SceneInfiniteLightCount)), SceneInfiniteLightCount - 1);
		LightPickPdf = 1.0 / SceneInfiniteLightCount;
		OutLightId = index;

			
		FLightSample Result = SampleLight(OutLightId, RandSample.yz, WorldPos, WorldNormal);
		OutDirection = Result.Direction;
		OutDistance = Result.Distance;
		OutRadianceOverPdf = Result.RadianceOverPdf / LightPickPdf;
		OutPdf = Result.Pdf * LightPickPdf;

		return true;
	}
	return false;
}


bool SampleTriangleLight(float2 RandSample,
	float3 WorldPos,
	float3 WorldNormal,
	int triId,
	float PickPdf,
	out float3 OutDirection,
	out float  OutDistance,
	out float3 OutRadianceOverPdf,
	out float OutPdf)
{

	OutDirection = 0;
	OutDistance = 0;
	OutRadianceOverPdf = 0;

	MeshLightInstanceTriangle prim = MeshLightInstancePrimitiveBuffer[triId];
    const float4x4 transform = MeshLightInstanceBuffer[prim.InstanceID].Transform;

	// const uint v0 = MeshLightIndexBuffer[triId * 3];
	// const uint v1 = MeshLightIndexBuffer[triId * 3 + 1];
	// const uint v2 = MeshLightIndexBuffer[triId * 3 + 2];
	uint v0 = MeshLightIndexBuffer[prim.IndexOffset];
	uint v1 = MeshLightIndexBuffer[prim.IndexOffset + 1];
	uint v2 = MeshLightIndexBuffer[prim.IndexOffset + 2];

	const float3 p0 = mul(float4(MeshLightVertexBuffer[v0],1.0f), transform).xyz;
	const float3 p1 = mul(float4(MeshLightVertexBuffer[v1],1.0f), transform).xyz;
	const float3 p2 = mul(float4(MeshLightVertexBuffer[v2],1.0f), transform).xyz;
	
	float3  Emission = MeshLightInstanceBuffer[prim.InstanceID].Emission;

	float3 LightN = cross(p2 - p0,p1 - p0);
	float Area = 0.5 * length(LightN);
	
	//sample a point in triangle
	float e1 = RandSample.x;
	float e2 = RandSample.y;
	float beta = e2 * sqrt(1 - e1);
	float gamma = 1 - sqrt(1 - e1);

	float3 SampleLightPos = p0 + beta * (p1 - p0) + gamma * (p2 - p0);

	float3 Direction = (SampleLightPos - WorldPos);
	float dSquared = max(dot(Direction, Direction), 1e-1) ;
	float LightDist = sqrt(dSquared);
	Direction /= LightDist;
	// Direction = normalize(Direction);
	// float LightDist = length(Direction);

	float dDotn = abs(dot(-Direction, normalize(LightN))) + 1e-4;
	//float Pdf = dSquared;
	//if( Area > 1e-4)
	float Pdf = dSquared / (Area * dDotn );
	//if( Pdf <= 0) return false;
	OutDirection = Direction;
	OutDistance =  LightDist - 8e-1;
	OutPdf = Pdf * PickPdf;
	OutRadianceOverPdf = Emission / OutPdf;

	return true;
}

bool SampleMeshLight(float3 RandSample,
	float3 WorldPos,
	float3 WorldNormal,
	int NodeID,
	out float3 OutDirection,
	out float  OutDistance,
	out float3 OutRadianceOverPdf,
	out float OutPdf)
{
	if( NumLightTriangles == 0)
		return false;
#if LIGHT_SAMPLING_TYPE == LIGHT_UNIFROM
	// pick a triangle
	int triId = min(int(floor(RandSample.x * NumLightTriangles)), NumLightTriangles - 1);
	float LightPickPdf = 1.0 / NumLightTriangles;
#elif LIGHT_SAMPLING_TYPE == LIGHT_TREE
	float LightPickPdf = 1.0;
	int triId = 0;
	bool deadBranch = TraverseLightTree(WorldPos, WorldNormal, 1, MeshLightNodesBuffer, 
				MeshLightLeafStartIndex, UseApproximateCosineBound, DistanceType,
				RandSample.x,LightPickPdf,triId);
	if( deadBranch ) return false;
#else
	float LightPickPdf = 1.0;
	int triId = 0;
	bool deadBranch = TraverseLightTree(WorldPos, WorldNormal, NodeID, MeshLightNodesBuffer, 
				MeshLightLeafStartIndex, UseApproximateCosineBound, DistanceType,
				RandSample.x,LightPickPdf,triId);
	if( deadBranch ) return false;
#endif
	return SampleTriangleLight(
		RandSample.yz,
		WorldPos,
		WorldNormal,
		triId,
		LightPickPdf,
		OutDirection,
		OutDistance,
		OutRadianceOverPdf,
		OutPdf
	);

}

bool SampleLightCut(
	float3 RandSample,
	float3 WorldPos,
	float3 WorldNormal,
	StructuredBuffer<FLightNode> LightNodes,
	int LeafStartIndex,
	int StartNodeID,
	uint PrimitiveLightingChannelMask,
	bool IsTransmissiveMaterial,
	out int OutLightId,
	out float3 OutDirection,
	out float  OutDistance,
	out float3 OutRadianceOverPdf,
	out float OutPdf)
{
	// set default values in case sampling fails
	OutLightId = -1;
	OutDirection = 0;
	OutDistance = 0;
	OutRadianceOverPdf = 0;
	OutPdf = 0;

	if (SceneLightCount == 0)
	{
		// no lights in the scene
		return false;
	}
	float LightPickPdf = 1.0;
	bool deadBranch = false;
	// float pInfinite = float(SceneInfiniteLightCount) /
    //                       float(SceneInfiniteLightCount + (SceneLightCount ==  SceneInfiniteLightCount? 0 : 1));
	float InfinteLightCdfSum = 0;
	// float LightPickingCdf[4];
	// int LightCdfCount = min(SceneInfiniteLightCount, 4);
	for (uint LightIndex = 0; LightIndex < SceneInfiniteLightCount; ++LightIndex)
	{
		InfinteLightCdfSum += EstimateLight(LightIndex, WorldPos, WorldNormal, PrimitiveLightingChannelMask, IsTransmissiveMaterial);
		// LightPickingCdf[LightIndex] = InfinteLightCdfSum;
	}
	FLightNode RootNode = LightNodes[1];
	float BoundCenter = RootNode.BoundMin + RootNode.BoundMax;
	float3 ToNode = (BoundCenter - WorldPos);
	float ToDist = length(ToNode);
	float NodeLightingEstimate =  RootNode.Intensity * dot(ToNode / ToDist, WorldNormal);// / ( ToDist * ToDist);
	
	float pInfinite = InfinteLightCdfSum / ( InfinteLightCdfSum + NodeLightingEstimate) ;
	if (RandSample.x < pInfinite) 
	{
		// Sample infinite lights with uniform probability
		RandSample.x /= pInfinite;
		int index = min(int(floor(RandSample.x * SceneInfiniteLightCount)), SceneInfiniteLightCount - 1);
		LightPickPdf = pInfinite / SceneInfiniteLightCount;
		OutLightId = index;
		int invSplitFactor = ceil(float(MaxCutNodes) / (InterleaveRate * InterleaveRate));
		LightPickPdf *= invSplitFactor;
	}
	else
	{
		deadBranch = TraverseLightTree(WorldPos, WorldNormal, StartNodeID, LightNodes, 
				LeafStartIndex, UseApproximateCosineBound, DistanceType,
				RandSample.x ,LightPickPdf,OutLightId );
		LightPickPdf *= 1- pInfinite;
	}
	if( deadBranch )
		return false;

	FLightSample Result = SampleLight(OutLightId, RandSample.yz, WorldPos, WorldNormal);
	OutDirection = Result.Direction;
	OutDistance = Result.Distance;
	OutRadianceOverPdf = Result.RadianceOverPdf / LightPickPdf;
	OutPdf = Result.Pdf * LightPickPdf;

	return true;
}

float3 PerformDirectLighting(float3 WorldPos, FGBufferData GBufferData, float3 V, float3 LightPos, float3 LightNormal, float3 LightE)
{
	half3 N = GBufferData.WorldNormal;
	float3 Direction = LightPos - WorldPos;
	half3 L = normalize(Direction);
	float NoL = saturate(dot(N, L));
	FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
	FDirectLighting LightingSample = EvaluateBxDF(GBufferData, N, V, L, NoL, ShadowTerms);
	float3 MaterialThroughput = LightingSample.Diffuse;
	MaterialThroughput += LightingSample.Transmission;	

	float Dist2 = dot(Direction, Direction);
	float sNoL = abs(dot(-L, LightNormal)); 
	float3 ExitantRadianceSample = LightE * MaterialThroughput * sNoL / Dist2;
	// Tonemap for firefly suppression
	if (UseFireflySuppression)
	{
		ExitantRadianceSample *= rcp(1.0 + Luminance(ExitantRadianceSample));
	}

	float3 Irradiance = isfinite(ExitantRadianceSample) ? ExitantRadianceSample : 0.0;
	return Irradiance;
}

float GetTargetPdf(float3 Irradiance)
{
	return dot(Irradiance, 1);
}

#if LIGHT_SAMPLING_TYPE == 5
#define REGIR_SAMPLING 1
#else
#define REGIR_SAMPLING 0
#endif

RAY_TRACING_ENTRY_RAYGEN(GlobalIlluminationRGS)
{
	uint2 DispatchThreadId = DispatchRaysIndex().xy + uint2(View.ViewRectMin.xy) + uint2(RenderTileOffsetX, RenderTileOffsetY);
	RWGlobalIlluminationUAV[DispatchThreadId] = 0.0;
	RWGlobalIlluminationRayDistanceUAV[DispatchThreadId] = float2(-1.0, 0.0);

	uint2 PixelCoord = GetPixelCoord(DispatchThreadId, UpscaleFactor);
	uint LinearIndex = CalcLinearIndex(PixelCoord);

	bool IsUnidirectionalEnabled = false;

	// Get G-Buffer surface data
	float2 InvBufferSize = View.BufferSizeAndInvSize.zw;
	float2 UV = (float2(PixelCoord) + 0.5) * InvBufferSize;

#if 0
	FGBufferData GBufferData = GetGBufferDataFromSceneTextures(UV);
#else
	//#dxr-todo: workaround for flickering. UE-87281
	FGBufferData GBufferData = GetGBufferDataFromSceneTexturesLoad(PixelCoord);
#endif
	// Remap DiffuseColor when using SubsurfaceProfile (GBuffer decoding replaces with 100% albedo)
	if (UseSubsurfaceProfile(GBufferData.ShadingModelID))
	{
		GBufferData.DiffuseColor = GBufferData.StoredBaseColor;
	}
	float DeviceZ = SceneDepthTexture.Load(int3(PixelCoord, 0)).r;
	float3 WorldPosition;
	float3 CameraDirection;
	ReconstructWorldPositionAndCameraDirectionFromDeviceZ(PixelCoord, DeviceZ, WorldPosition, CameraDirection);
	float3 WorldNormal = GBufferData.WorldNormal;
	uint ShadingModelID = GBufferData.ShadingModelID;
	if (ShadingModelID == SHADINGMODELID_UNLIT)
	{
		return;
	}

	// Diffuse color rejection threshold
	float3 DiffuseColor = GBufferData.DiffuseColor;
	if (Luminance(DiffuseColor) < DiffuseThreshold)
	{
		return;
	}

	float3 Irradiance = 0;
	float HitDistance = 0.0;
	float HitCount = 0.0;
	float AmbientOcclusion = 0.0;

	NvTimingQuery Query = (NvTimingQuery)0;
	BRANCH
	if (Query.SupportTiming() && AccumulateTime)
	{
		Query.StartTimer();
	}
#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
	// uint2 BufferSize = View.BufferSizeAndInvSize.xy;
	uint2 BufferSize = ceil(View.BufferSizeAndInvSize.xy / UpscaleFactor);
	uint2 Pixel = DispatchThreadId;
	// uint2 Pixel = PixelCoord;
	int startAddr =  MAX_CUT_NODES * ( (Pixel.y / CutShareGroupSize) * ((BufferSize.x + CutShareGroupSize - 1) / CutShareGroupSize) + Pixel.x / CutShareGroupSize );

	uint numPass = ceil(float(MaxCutNodes) / (InterleaveRate * InterleaveRate));
#endif
	FRandomContext RandContext = FRandomContext::Create(LinearIndex, View.StateFrameIndex);
	for (uint SampleIndex = 0; SampleIndex < SamplesPerPixel; ++SampleIndex)
	{
		RandomSequence RandSequence;
		RandomSequence_Initialize(RandSequence, PixelCoord, SampleIndex, View.StateFrameIndex, SamplesPerPixel);
		float3 RayThroughput = 1.0;
		float3 RandSample = RandomSequence_GenerateSample3D(RandSequence);
#if MESH_LIGHT_SAMPLING

#if REGIR_SAMPLING
		// float3 RandSample3 = RandContext.GenerateSample3D();
		float3 GridCellSize = (LightBoundMax - LightBoundMin) / GridCellDim;
    	float3 CellRandomOffset = GridCellSize * float3(-0.5f + RandSample.x,
                          -0.5f + RandSample.y,
                          -0.5f + RandSample.z);

		uint3 CellCoord = GetCellIndexFromPos(WorldPosition + CellRandomOffset);
		uint CellStartIndex = CalcCellLinearIndex(CellCoord, 0) * NumLightSlotsPerCell;
		uint BufferIndex = 0;//View.StateFrameIndex % 2;
		// const uint numResampling = NumCandidatesPerCell;
		ReGIR_Reservoir state = ReGIR_Reservoir::Empty();
		float3 selectCon = 0.0;
		for (int i = 0; i < NumCandidatesPerCell; ++i) 
		{
			float2 RandSample2 = RandomSequence_GenerateSample2D(RandSequence);
			//float2 RandSample2 = RandContext.GenerateSample2D();
			uint lightSlotIdx = CellStartIndex + min(uint(RandSample2.x * NumLightSlotsPerCell), NumLightSlotsPerCell - 1);
			ReGIR_Reservoir rerservoir = ReGIR_Reservoir::Load(ReadReservoirData(lightSlotIdx, BufferIndex));
			ReGIR_SampleRef sampleRef = rerservoir.sampleRef;
			float3 cont = PerformDirectLighting(WorldPosition, GBufferData, -CameraDirection, sampleRef.Position , sampleRef.Normal, sampleRef.Irradiance);
			float targetPdf = Luminance(cont);
			
			if( state.CombineReservoirs(rerservoir, RandSample2.y,targetPdf) )
			{
				selectCon = cont;
			}
		}
		state.FinalizeResampling(1.0, state.M);

		if( state.sampleRef.IsValid() )
		{
			float3 LightDirection = state.sampleRef.Position - WorldPosition;
			float3 LightNormal = state.sampleRef.Normal;
			float LightDist =  sqrt(dot(LightDirection, LightDirection)) - 8e-1;

			RayDesc LightRay;
			LightRay.Origin = WorldPosition;
			LightRay.TMin = 0;
			LightRay.Direction = normalize(LightDirection);
			LightRay.TMax = min(LightDist, MaxShadowDistance);
			bool bTransmission = true;
			float3 BiasNormal = WorldNormal;
			if ( dot(BiasNormal, LightRay.Direction) < 0.0)
			{
				BiasNormal = -BiasNormal;
			}
			ApplyPositionBias(LightRay, BiasNormal, MaxNormalBias);

			// Trace visibility ray
			uint NeeRayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
			const uint NeeInstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;

#if !ENABLE_TWO_SIDED_GEOMETRY
			NeeRayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
#endif

			FMinimalPayload NeePayload = TraceVisibilityRay(
				TLAS,
				NeeRayFlags,
				NeeInstanceInclusionMask,
				PixelCoord,
				LightRay);

			// No hit indicates successful next-event connection
			if (NeePayload.IsMiss())
			{
				float3 ExitantRadianceSample =  selectCon * state.weightSum;
				// Tonemap for firefly suppression
				if (UseFireflySuppression)
				{
					ExitantRadianceSample *= rcp(1.0 + Luminance(ExitantRadianceSample));
				}

				Irradiance += isfinite(ExitantRadianceSample) ? ExitantRadianceSample : 0.0;
				//  Irradiance += state.weightSum;
			}
		}
		// WriteReservoirHistoryData(resStartIndex ,state.Store());
#else

	#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
		float factor = 1.0 ;
		for(uint NeeTrial = 0; NeeTrial < numPass; ++NeeTrial)
	#else
		float factor = 1.0 / NextEventEstimationSamples;
		for (uint NeeTrial = 0; NeeTrial < NextEventEstimationSamples; ++NeeTrial)
	#endif
		{
			float3 LightRadianceOverPdf = 0;
			float NeePdf = 0.0;

			float3 RandSample3 = RandomSequence_GenerateSample3D(RandSequence);
			RayDesc LightRay;
			int NodeID = 1;
		#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
			if( CutShareGroupSize > 0)
			{
				int cutNodeId = NeeTrial;

				int startId = 0;
				int endId = MaxCutNodes;

				if (InterleaveRate > 1)
				{
					int interleaveGroupSize = InterleaveRate * InterleaveRate;
					int interleaveSamplingId = ( View.StateFrameIndex + InterleaveRate * (Pixel.y % InterleaveRate) + (Pixel.x % InterleaveRate)) % interleaveGroupSize;

					float ratio = float(MaxCutNodes) / interleaveGroupSize;
					startId = int(interleaveSamplingId * ratio);  
					endId = interleaveSamplingId == interleaveGroupSize - 1 ? MaxCutNodes : int((interleaveSamplingId + 1) * ratio);

					if (startId + NeeTrial >= endId) break;
					else
					{
						cutNodeId = startId + NeeTrial;
					}
				}
				else
				{
					if (cutNodeId >= MaxCutNodes) break;
				}
				int cutID = cutNodeId + startAddr;
				NodeID = MeshLightCutBuffer[cutID];
				if (NodeID < 0) break;
			}
		#endif
			if( SampleMeshLight(RandSample3,
						WorldPosition,
						WorldNormal,
						NodeID,
						LightRay.Direction,
						LightRay.TMax,
						LightRadianceOverPdf,
						NeePdf) )
			{
		#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
			LightRadianceOverPdf *= ( InterleaveRate * InterleaveRate);
		#endif
				LightRay.Origin = WorldPosition;
				LightRay.TMin = 0;
				LightRay.TMax = min(LightRay.TMax, MaxShadowDistance);
				bool bTransmission = true;
				float3 BiasNormal = WorldNormal;
				if ( dot(BiasNormal, LightRay.Direction) < 0.0)
				{
					BiasNormal = -BiasNormal;
				}
				ApplyPositionBias(LightRay, BiasNormal, MaxNormalBias);

				// Trace visibility ray
				uint NeeRayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
				const uint NeeInstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;

#if !ENABLE_TWO_SIDED_GEOMETRY
				NeeRayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
#endif

				FMinimalPayload NeePayload = TraceVisibilityRay(
					TLAS,
					NeeRayFlags,
					NeeInstanceInclusionMask,
					PixelCoord,
					LightRay);

				// No hit indicates successful next-event connection
				if (NeePayload.IsMiss())
				{
					// Evaluate material
					float3 MaterialThroughput;
					half3 N = WorldNormal;
					half3 V = -CameraDirection;
					half3 L = LightRay.Direction;
					float NoL = saturate(dot(N, L));
					FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
					FDirectLighting LightingSample = EvaluateBxDF(GBufferData, N, V, L, NoL, ShadowTerms);
					MaterialThroughput = LightingSample.Diffuse;
					if (bTransmission)
					{
						MaterialThroughput += LightingSample.Transmission;
					}

					// Record the contribution
	
					float3 ExitantRadianceSample = LightRadianceOverPdf * MaterialThroughput * factor;
					// float3 ExitantRadianceSample = float3(1,0,0);
					// Tonemap for firefly suppression
					if (UseFireflySuppression)
					{
						ExitantRadianceSample *= rcp(1.0 + Luminance(ExitantRadianceSample));
					}

					Irradiance += isfinite(ExitantRadianceSample) ? ExitantRadianceSample : 0.0;
				}
			}
		}
#endif	// REGIR_SAMPLING
#endif //MESH_LIGHT_SAMPLING

		// Russian roulette based on DiffuseColor
		if (UseRussianRoulette)
		{
			float RRSample = RandSample.x;
			float ProbabilityOfSuccess = Luminance(DiffuseColor);
			float ProbabilityOfTermination = 1.0 - ProbabilityOfSuccess;
			if (RRSample < ProbabilityOfTermination) continue;
			RayThroughput /= ProbabilityOfSuccess;
		}

		// Initialize ray
		RayDesc Ray;
		float RayPdf = 1.0;
#if 1
		GenerateCosineNormalRay(WorldPosition, WorldNormal, RandSample.yz, Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax, RayPdf);
		half3 N = WorldNormal;
		half3 V = -CameraDirection;
		half3 L = Ray.Direction;
		float NoL = saturate(dot(N, L));
		FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
		FDirectLighting LightingSample = EvaluateBxDF(GBufferData, N, V, L, NoL, ShadowTerms);
		RayThroughput *= LightingSample.Diffuse / DiffuseColor;
#else
		float2 RandSample = RandomSequence_GenerateSample2D(RandSequence);
		float2 ViewportUV = (PixelCoord.xy + RandSample.xy) * View.BufferSizeAndInvSize.zw;
		Ray.Origin = ReconstructWorldPositionFromDepth(ViewportUV, 0.0f);
		Ray.Direction = normalize(ReconstructWorldPositionFromDepth(ViewportUV, 1.f) - Ray.Origin);
		Ray.TMin = 0.0;
		Ray.TMax = 1.0e12;
		float3 RayThroughput = 1.0;
#endif
		Ray.TMax = max(MaxRayDistanceForGI, MaxRayDistanceForAO);
		ApplyCameraRelativeDepthBias(Ray, PixelCoord, DeviceZ, WorldNormal, MaxNormalBias);
		
		float MaterialPdf = 0.0;
		uint Bounce = 0;
		while (Bounce < MaxBounces)
		{
			// Cast ray
			uint RayFlags = 0;
			const uint InstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;
			const bool bEnableSkyLightContribution = true;
			const bool bIgnoreTranslucentMaterials = false;

#if !ENABLE_TWO_SIDED_GEOMETRY
			RayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
#endif

			FRayCone RayCone = (FRayCone)0;
			FMaterialClosestHitPayload Payload = TraceMaterialRay(
				TLAS,
				RayFlags,
				InstanceInclusionMask,
				Ray,
				RayCone,
				PixelCoord,
				bEnableSkyLightContribution,
				bIgnoreTranslucentMaterials);

			// Environment hit
			if (Payload.IsMiss())
			{
				// Optional multi-bounce SkyLight contribution
				if (EvalSkyLight && Bounce > 0)
				{
					uint SkyLightId = 0;
					RayDesc LightRay = Ray;
					LightRay.TMax = POSITIVE_INFINITY;
					float3 EnvironmentRadiance = SkyLight_TraceLight(Ray, SkyLightId).Radiance;
					Irradiance += EnvironmentRadiance * RayThroughput / RayPdf;
				}
				break;
			}

			if (Bounce == 0)
			{
				HitDistance += Payload.HitT;
				HitCount += 1.0;
				if (Payload.HitT < MaxRayDistanceForAO)
				{
					AmbientOcclusion += 1.0;
				}
			}
			if (Payload.HitT > MaxRayDistanceForGI) break;

			// Update intersection
			Ray.Origin += Ray.Direction * Payload.HitT;

			// Create faux GBuffer to use with EvaluateBxDF
			FGBufferData GBufferData = (FGBufferData)0;
			GBufferData.Depth = 1.f; // Do not use depth
			GBufferData.WorldNormal = Payload.WorldNormal;
			GBufferData.BaseColor = Payload.BaseColor;
			GBufferData.CustomData = Payload.CustomData;
			GBufferData.GBufferAO = Payload.GBufferAO;
			GBufferData.IndirectIrradiance = (Payload.IndirectIrradiance.x + Payload.IndirectIrradiance.y + Payload.IndirectIrradiance.z) / 3.f;
			GBufferData.SpecularColor = Payload.SpecularColor;
			GBufferData.DiffuseColor = Payload.DiffuseColor;			
			GBufferData.Metallic = Payload.Metallic;
			GBufferData.Specular = Payload.Specular;
			GBufferData.Roughness = Payload.Roughness;
			GBufferData.ShadingModelID = Payload.ShadingModelID;
			GBufferData.CustomData = Payload.CustomData;

#if !MESH_LIGHT_SAMPLING
			if (AccumulateEmissive)
			{
				Irradiance += Payload.Radiance * RayThroughput / RayPdf;
			}
#else
#if REGIR_SAMPLING
		float3 CellRandSample = RandomSequence_GenerateSample3D(RandSequence);
		float3 GridCellSize = (LightBoundMax - LightBoundMin) / GridCellDim;
    	float3 CellRandomOffset = GridCellSize * float3(-0.5f + CellRandSample.x,
                          -0.5f + CellRandSample.y,
                          -0.5f + CellRandSample.z);

		uint3 CellCoord = GetCellIndexFromPos(WorldPosition + CellRandomOffset);
		uint CellStartIndex = CalcCellLinearIndex(CellCoord, 0) * NumLightSlotsPerCell;
		uint BufferIndex = 0;//View.StateFrameIndex % 2;
		// const uint numResampling = NumCandidatesPerCell;
		ReGIR_Reservoir state = ReGIR_Reservoir::Empty();
		float3 selectCon = 0.0;
		for (int i = 0; i < NumCandidatesPerCell; ++i) 
		{
			float2 RandSample2 = RandomSequence_GenerateSample2D(RandSequence);
			//float2 RandSample2 = RandContext.GenerateSample2D();
			uint lightSlotIdx = CellStartIndex + min(uint(RandSample2.x * NumLightSlotsPerCell), NumLightSlotsPerCell - 1);
			ReGIR_Reservoir rerservoir = ReGIR_Reservoir::Load(ReadReservoirData(lightSlotIdx, BufferIndex));
			ReGIR_SampleRef sampleRef = rerservoir.sampleRef;
			float3 cont = PerformDirectLighting(WorldPosition, GBufferData, -CameraDirection, sampleRef.Position , sampleRef.Normal, sampleRef.Irradiance);
			float targetPdf = Luminance(cont);
			
			if( state.CombineReservoirs(rerservoir, RandSample2.y,targetPdf) )
			{
				selectCon = cont;
			}
		}
		state.FinalizeResampling(1.0, state.M);

		if( state.sampleRef.IsValid() )
		{
			float3 LightDirection = state.sampleRef.Position - WorldPosition;
			float3 LightNormal = state.sampleRef.Normal;
			float LightDist =  sqrt(dot(LightDirection, LightDirection)) - 8e-1;

			RayDesc LightRay;
			LightRay.Origin = WorldPosition;
			LightRay.TMin = 0;
			LightRay.Direction = normalize(LightDirection);
			LightRay.TMax = min(LightDist, MaxShadowDistance);
			bool bTransmission = true;
			float3 BiasNormal = WorldNormal;
			if ( dot(BiasNormal, LightRay.Direction) < 0.0)
			{
				BiasNormal = -BiasNormal;
			}
			ApplyPositionBias(LightRay, BiasNormal, MaxNormalBias);

			// Trace visibility ray
			uint NeeRayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
			const uint NeeInstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;

#if !ENABLE_TWO_SIDED_GEOMETRY
			NeeRayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
#endif

			FMinimalPayload NeePayload = TraceVisibilityRay(
				TLAS,
				NeeRayFlags,
				NeeInstanceInclusionMask,
				PixelCoord,
				LightRay);

			// No hit indicates successful next-event connection
			if (NeePayload.IsMiss())
			{
				float3 ExitantRadianceSample =  selectCon * state.weightSum * RayThroughput / RayPdf;;
				// Tonemap for firefly suppression
				if (UseFireflySuppression)
				{
					ExitantRadianceSample *= rcp(1.0 + Luminance(ExitantRadianceSample));
				}

				Irradiance += isfinite(ExitantRadianceSample) ? ExitantRadianceSample : 0.0;
				//  Irradiance += state.weightSum;
			}
		}
		// WriteReservoirHistoryData(resStartIndex ,state.Store());
#else
	#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
			for(uint NeeID = 0; NeeID < numPass; ++NeeID)
	#else
			for (uint NeeID = 0; NeeID < NextEventEstimationSamples; ++NeeID)
	#endif
			{
				float3 LightRadianceOverPdf = 0;
				float NeePdf = 0.0;

				float3 RandSample3 = RandomSequence_GenerateSample3D(RandSequence);
				RayDesc LightRay;
				int nodeID = 1;
			#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
				if( CutShareGroupSize > 0)
				{
					int cutNodeId = NeeID;

					int startId = 0;
					int endId = MaxCutNodes;

					if (InterleaveRate > 1)
					{
						int interleaveGroupSize = InterleaveRate * InterleaveRate;
						int interleaveSamplingId = ( View.StateFrameIndex + InterleaveRate * (Pixel.y % InterleaveRate) + (Pixel.x % InterleaveRate)) % interleaveGroupSize;

						float ratio = float(MaxCutNodes) / interleaveGroupSize;
						startId = int(interleaveSamplingId * ratio);  
						endId = interleaveSamplingId == interleaveGroupSize - 1 ? MaxCutNodes : int((interleaveSamplingId + 1) * ratio);

						if (startId + NeeID >= endId) break;
						else
						{
							cutNodeId = startId + NeeID;
						}
					}
					else
					{
						if (cutNodeId >= MaxCutNodes) break;
					}
					int cutID = cutNodeId + startAddr;
					nodeID = MeshLightCutBuffer[cutID];
					if (nodeID < 0) break;
				}
			#endif
				if( SampleMeshLight(RandSample3,
							Ray.Origin,
							Payload.WorldNormal,
							nodeID,
							LightRay.Direction,
							LightRay.TMax,
							LightRadianceOverPdf,
							NeePdf) )
				{
		#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
			LightRadianceOverPdf *= ( InterleaveRate * InterleaveRate);
		#endif
					LightRay.Origin = Ray.Origin;
					LightRay.TMin = 0;
					LightRay.TMax = min(LightRay.TMax, MaxShadowDistance);
					bool bTransmission = true;
					float3 BiasNormal = Payload.WorldNormal;
					if ( dot(BiasNormal, LightRay.Direction) < 0.0)
					{
						BiasNormal = -BiasNormal;
					}
					ApplyPositionBias(LightRay, BiasNormal, MaxNormalBias);

					// Trace visibility ray
					uint NeeRayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
					const uint NeeInstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;

	#if !ENABLE_TWO_SIDED_GEOMETRY
					NeeRayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
	#endif

					FMinimalPayload NeePayload = TraceVisibilityRay(
						TLAS,
						NeeRayFlags,
						NeeInstanceInclusionMask,
						PixelCoord,
						LightRay);

					// No hit indicates successful next-event connection
					if (NeePayload.IsMiss())
					{
						// Evaluate material
						float3 MaterialThroughput;
	#if USE_PATHTRACING_MATERIALS
						FMaterialEval MaterialEval = EvalMaterial(CameraDirection, LightRay.Direction, Payload, false);
						MaterialThroughput = MaterialEval.Weight * MaterialEval.Pdf;
	#else
						half3 N = Payload.WorldNormal;
						half3 V = -Ray.Direction;
						half3 L = LightRay.Direction;
						float NoL = saturate(dot(N, L));
						FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
						FDirectLighting LightingSample = EvaluateBxDF(GBufferData, N, V, L, NoL, ShadowTerms);
						MaterialThroughput = LightingSample.Diffuse;
						if (bTransmission)
						{
							MaterialThroughput += LightingSample.Transmission;
						}
	#endif

						// Record the contribution
						float3 ExitantRadianceSample = LightRadianceOverPdf * MaterialThroughput* RayThroughput * factor / RayPdf;
						// float3 ExitantRadianceSample = float3(1,0,0);
						// Tonemap for firefly suppression
						if (UseFireflySuppression)
						{
							ExitantRadianceSample *= rcp(1.0 + Luminance(ExitantRadianceSample));
						}

						Irradiance += isfinite(ExitantRadianceSample) ? ExitantRadianceSample : 0.0;
					}
				}
			}

#endif // REGIR_RESAMPLING
#endif //MESH_SAMPLING

#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
			// uint2 BufferSize = View.BufferSizeAndInvSize.xy;
			// int startAddr =  MAX_CUT_NODES * ( (PixelCoord.y / CutShareGroupSize) * ((BufferSize.x + CutShareGroupSize - 1) / CutShareGroupSize) + PixelCoord.x / CutShareGroupSize );

			// int numPass = ceil(float(MaxCutNodes) / (InterleaveRate * InterleaveRate));
			float SplitFactor = 1.0;
			for(uint NeeTrial = 0; NeeTrial < numPass; ++NeeTrial)
			{
#else
			// Perform next-event estimation
			float SplitFactor = 1.0 / NextEventEstimationSamples;
			for (uint NeeTrial = 0; NeeTrial < NextEventEstimationSamples; ++NeeTrial)
			{
#endif
				// Light selection
				int LightId;
				float3 LightRadianceOverPdf = 0;
				float NeePdf = 0.0;

				float3 RandSample3 = RandomSequence_GenerateSample3D(RandSequence);
				RayDesc LightRay;
			
				#if LIGHT_SAMPLING_TYPE == LIGHT_TREE
				bool bLit = SampleLightTree(RandSample3,
							Ray.Origin,
							Payload.WorldNormal,
							NodesBuffer,
							LeafStartIndex,
							1,
							Payload.PrimitiveLightingChannelMask,
							ENABLE_TRANSMISSION,
							LightId,
							LightRay.Direction,
							LightRay.TMax,
							LightRadianceOverPdf,
							NeePdf);
				#elif LIGHT_SAMPLING_TYPE == LIGHT_CUT
				bool bLit = false;
				if( CutShareGroupSize > 0)
				{
					int cutNodeId = NeeTrial;

					int startId = 0;
					int endId = MaxCutNodes;

					if (InterleaveRate > 1)
					{
						int interleaveGroupSize = InterleaveRate * InterleaveRate;
						int interleaveSamplingId = ( View.StateFrameIndex + InterleaveRate * (Pixel.y % InterleaveRate) + (Pixel.x % InterleaveRate)) % interleaveGroupSize;

						float ratio = float(MaxCutNodes) / interleaveGroupSize;
						startId = int(interleaveSamplingId * ratio);  
						endId = interleaveSamplingId == interleaveGroupSize - 1 ? MaxCutNodes : int((interleaveSamplingId + 1) * ratio);

						if (startId + NeeTrial >= endId) break;
						else
						{
							cutNodeId = startId + NeeTrial;
						}
					}
					else
					{
						if (cutNodeId >= MaxCutNodes) break;
					}
					int cutID = cutNodeId + startAddr;
					int nodeID = LightCutBuffer[cutID];
					if (nodeID < 0) break;
					bLit = SampleLightCut(RandSample3,
							Ray.Origin,
							Payload.WorldNormal,
							NodesBuffer,
							LeafStartIndex,
							nodeID,
							Payload.PrimitiveLightingChannelMask,
							ENABLE_TRANSMISSION,
							LightId,
							LightRay.Direction,
							LightRay.TMax,
							LightRadianceOverPdf,
							NeePdf);	
					LightRadianceOverPdf *= ( InterleaveRate * InterleaveRate);
				}
				// else
				// {

				// }
				#else
				bool bLit = SampleLight(RandSample3,
							Ray.Origin,
							Payload.WorldNormal,
							Payload.PrimitiveLightingChannelMask,
							ENABLE_TRANSMISSION,
							LightId,
							LightRay.Direction,
							LightRay.TMax,
							LightRadianceOverPdf,
							NeePdf);
				#endif
				if (bLit)
				{
					LightRay.Origin = Ray.Origin;
					LightRay.TMin = 0;
					LightRay.TMax = min(LightRay.TMax, MaxShadowDistance);
					bool bTransmission = HasTransmission(LightId);
					float3 BiasNormal = Payload.WorldNormal;
					if (bTransmission && dot(BiasNormal, LightRay.Direction) < 0.0)
					{
						BiasNormal = -BiasNormal;
					}
					ApplyPositionBias(LightRay, BiasNormal, MaxNormalBias);

					// Trace visibility ray
					uint NeeRayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
					const uint NeeInstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;

#if !ENABLE_TWO_SIDED_GEOMETRY
					NeeRayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
#endif

					FMinimalPayload NeePayload = TraceVisibilityRay(
						TLAS,
						NeeRayFlags,
						NeeInstanceInclusionMask,
						PixelCoord,
						LightRay);

					// No hit indicates successful next-event connection
					if (NeePayload.IsMiss())
					{
						// Evaluate material
						float3 MaterialThroughput;
#if USE_PATHTRACING_MATERIALS
						//EvalMaterial(Ray.Direction, LightRay.Direction, Payload, MaterialWeight, MaterialEvalPdf);
						FMaterialEval MaterialEval = EvalMaterial(CameraDirection, LightRay.Direction, Payload, false);
						MaterialThroughput = MaterialEval.Weight * MaterialEval.Pdf;
#else
						half3 N = Payload.WorldNormal;
						half3 V = -Ray.Direction;
						half3 L = LightRay.Direction;
						float NoL = saturate(dot(N, L));
						FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
						FDirectLighting LightingSample = EvaluateBxDF(GBufferData, N, V, L, NoL, ShadowTerms);
						MaterialThroughput = LightingSample.Diffuse;
						if (bTransmission)
						{
							MaterialThroughput += LightingSample.Transmission;
						}
#endif

						// Record the contribution
						float3 ExitantRadianceSample = LightRadianceOverPdf * MaterialThroughput * RayThroughput * SplitFactor / RayPdf;

						// Tonemap for firefly suppression
						if (UseFireflySuppression)
						{
							ExitantRadianceSample *= rcp(1.0 + Luminance(ExitantRadianceSample));
						}

						Irradiance += isfinite(ExitantRadianceSample) ? ExitantRadianceSample : 0.0;
					}
				}
			}

			// Perform material sampling
			if (Bounce + 1 < MaxBounces)
			{
				float3 Direction;
				float3 Throughput = 1.0;
#if USE_PATHTRACING_MATERIALS
				RandSample4 = RandomSequence_GenerateSample4D(RandSequence);

				float PositionBiasSign;
				float3 Weight = 0;
				SampleMaterial(Ray.Direction, Payload, RandSample, Direction, Weight, MaterialPdf, PositionBiasSign);
				Throughput = Weight * MaterialPdf;
#else

				float3 RandSample3 = RandomSequence_GenerateSample3D(RandSequence);

				float3 RayOrigin = Ray.Origin;
				GenerateCosineNormalRay(RayOrigin, Payload.WorldNormal, RandSample3.xy, Ray.Origin, Direction, Ray.TMin, Ray.TMax, MaterialPdf);
				
				half3 N = Payload.WorldNormal;
				half3 V = -Ray.Direction;
				half3 L = Direction;
				float NoL = saturate(dot(N, L));
				FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
				FDirectLighting LightingSample = EvaluateBxDF(GBufferData, N, V, L, NoL, ShadowTerms);
				Throughput = LightingSample.Diffuse;
#endif
				if (MaterialPdf <= 0.0)
				{
					break;
				}

				// Update ray
				Ray.Direction = Direction;
				RayThroughput *= Throughput;
				RayPdf *= MaterialPdf;
			}

			Bounce++;
		}
	}

	BRANCH
	if (Query.SupportTiming() && AccumulateTime)
	{
		Query.StopTimer();

		Query.RecordTiming(CumulativeTime, PixelCoord, UpscaleFactor);
	}

	if (SamplesPerPixel > 0)
	{
		Irradiance /= SamplesPerPixel;
		// Tonemap inversion for firefly suppression
		if (UseFireflySuppression)
		{
			Irradiance *= rcp(1 - Luminance(Irradiance));
		}

		AmbientOcclusion /= SamplesPerPixel;
	}

	if (HitCount > 0.0)
	{
		HitDistance /= HitCount;
	}
	else
	{
		HitDistance = -1.0;
	}

	AmbientOcclusion = saturate(AmbientOcclusion);

#if USE_PREEXPOSURE
	Irradiance *= View.PreExposure;
#endif

	Irradiance = ClampToHalfFloatRange(Irradiance);
	RWGlobalIlluminationUAV[DispatchThreadId] = float4(Irradiance, AmbientOcclusion);
	RWGlobalIlluminationRayDistanceUAV[DispatchThreadId] = float2(HitDistance, SamplesPerPixel);
	// For AO denoiser..
	//RWGlobalIlluminationRayDistanceUAV[DispatchThreadId] = float2(Luminance(Irradiance), HitDistance);
}
