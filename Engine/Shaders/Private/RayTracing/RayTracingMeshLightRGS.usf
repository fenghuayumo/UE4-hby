

#define USE_IES_TERM 0 // this shader doesn't bind the IES atlas, so disable the IES term from path tracer lights

#include "../Common.ush"
#include "../RectLight.ush"
//#include "../MonteCarlo.ush"
#include "../DeferredShadingCommon.ush"
#include "../ShadingModels.ush"
#include "../SceneTextureParameters.ush"
#include "RayTracingCommon.ush"
#include "RayTracingDeferredShadingCommon.ush"
#include "RayTracingHitGroupCommon.ush"

#include "../PathTracing/Material/PathTracingMaterialSampling.ush"
#include "../PathTracing/Utilities/PathTracingRandomSequence.ush"

uint SamplesPerPixel;
uint UpscaleFactor;
float MaxRayDistanceForMeshLight;
float MaxShadowDistance;
float NextEventEstimationSamples;
uint UseFireflySuppression;

RaytracingAccelerationStructure TLAS;

RWTexture2D<float4> RWMeshLightIllumianceUAV;
RWTexture2D<float2> RWMeshLightRayDistanceUAV;

StructuredBuffer<int> LightCutBuffer;
StructuredBuffer<FLightNode> NodesBuffer;

StructuredBuffer<float3>       MeshLightVertexBuffer;
StructuredBuffer<uint>         MeshLightIndexBuffer;
StructuredBuffer<MeshLightInstanceTriangle>    MeshLightInstancePrimitiveBuffer;
StructuredBuffer<MeshLightInstance>   MeshLightInstanceBuffer;
uint 							NumLightTriangles;
bool SampleMeshLight(float3 RandSample,
	float3 WorldPos,
	float3 WorldNormal,
	out float3 OutDirection,
	out float  OutDistance,
	out float3 OutRadianceOverPdf,
	out float OutPdf)
{
	if( NumLightTriangles == 0)
		return false;
	OutDirection = 0;
	OutDistance = 0;
	OutRadianceOverPdf = 0;

	// sample a triangle
	int triId = min(int(floor(RandSample.x * NumLightTriangles)), NumLightTriangles - 1);

	MeshLightInstanceTriangle prim = MeshLightInstancePrimitiveBuffer[triId];
    const float4x4 transform = MeshLightInstanceBuffer[prim.InstanceID].Transform;

	const uint v0 = MeshLightIndexBuffer[triId * 3];
	const uint v1 = MeshLightIndexBuffer[triId * 3 + 1];
	const uint v2 = MeshLightIndexBuffer[triId * 3 + 2];

	const float3 p0 = mul(float4(MeshLightVertexBuffer[v0],1.0), transform).xyz;
	const float3 p1 = mul(float4(MeshLightVertexBuffer[v1],1.0), transform).xyz;
	const float3 p2 = mul(float4(MeshLightVertexBuffer[v2],1.0), transform).xyz;
	
	float3  Emission = MeshLightInstanceBuffer[prim.InstanceID].Emission;

	float3 LightN = -cross(p1 - p0,p2 - p0);
	float Area = 0.5 * length(LightN);
	
	//sample triangle
	float e1 = RandSample.y;
	float e2 = RandSample.z;
	float beta = e2 * sqrt(1 - e1);
	float gamma = 1 - sqrt(1 - e1);

	float3 SampleLightPos = p0 + beta * (p1 - p0) + gamma * (p2 - p0);

	float3 Direction = (SampleLightPos - WorldPos);
	float dSquared = dot(Direction, Direction);
	float LightDist = sqrt(dSquared);
	Direction /= (LightDist + 1e-6);
	// Direction = normalize(Direction);
	// float LightDist = length(Direction);
	float PickPdf = 1.0 / NumLightTriangles;
	float dDotn = dot(-Direction, normalize(LightN));
	// float pdf = dDotn < 0 ? 0 : dSquared / (Area * dDotn);
	float Pdf = dSquared / (Area * dDotn);
	if( Pdf <= 0) return false;
	OutDirection = Direction;
	OutDistance = LightDist ;
	OutPdf = PickPdf * Pdf;
	OutRadianceOverPdf = Emission / OutPdf;

	return true;
}

RAY_TRACING_ENTRY_RAYGEN(MeshLightRGS)
{
	uint2 DispatchThreadId = DispatchRaysIndex().xy + uint2(View.ViewRectMin.xy) + uint2(RenderTileOffsetX, RenderTileOffsetY);
	RWMeshLightIllumianceUAV[DispatchThreadId] = 0.0;
	RWGlobalIlluminationRayDistanceUAV[DispatchThreadId] = float2(-1.0, 0.0);

	uint2 PixelCoord = GetPixelCoord(DispatchThreadId, UpscaleFactor);
	uint LinearIndex = CalcLinearIndex(PixelCoord);

	bool IsUnidirectionalEnabled = false;

	// Get G-Buffer surface data
	float2 InvBufferSize = View.BufferSizeAndInvSize.zw;
	float2 UV = (float2(PixelCoord) + 0.5) * InvBufferSize;

#if 0
	FGBufferData GBufferData = GetGBufferDataFromSceneTextures(UV);
#else
	//#dxr-todo: workaround for flickering. UE-87281
	FGBufferData GBufferData = GetGBufferDataFromSceneTexturesLoad(PixelCoord);
#endif
	// Remap DiffuseColor when using SubsurfaceProfile (GBuffer decoding replaces with 100% albedo)
	if (UseSubsurfaceProfile(GBufferData.ShadingModelID))
	{
		GBufferData.DiffuseColor = GBufferData.StoredBaseColor;
	}
	float DeviceZ = SceneDepthTexture.Load(int3(PixelCoord, 0)).r;
	float3 WorldPosition;
	float3 CameraDirection;
	ReconstructWorldPositionAndCameraDirectionFromDeviceZ(PixelCoord, DeviceZ, WorldPosition, CameraDirection);
	float3 WorldNormal = GBufferData.WorldNormal;
	uint ShadingModelID = GBufferData.ShadingModelID;
	if (ShadingModelID == SHADINGMODELID_UNLIT)
	{
		return;
	}

    float3 Irradiance = 0;
	float HitDistance = 0.0;
	float HitCount = 0.0;
	float AmbientOcclusion = 0.0;

    for (uint SampleIndex = 0; SampleIndex < SamplesPerPixel; ++SampleIndex)
    {
        RandomSequence RandSequence;
		RandomSequence_Initialize(RandSequence, PixelCoord, SampleIndex, View.StateFrameIndex, SamplesPerPixel);
        float3 LightRadianceOverPdf = 0;
        float NeePdf = 0.0;

        float3 RandSample3 = RandomSequence_GenerateSample3D(RandSequence);
        RayDesc LightRay;
        if( SampleMeshLight(RandSample3,
                    WorldPosition,
                    WorldNormal,
                    LightRay.Direction,
                    LightRay.TMax,
                    LightRadianceOverPdf,
                    NeePdf) )
        {
            LightRay.Origin = WorldPosition;
            LightRay.TMin = 0;
            LightRay.TMax = min(LightRay.TMax - 1e-1, MaxShadowDistance);
            bool bTransmission = true;
            float3 BiasNormal = WorldNormal;
            if ( dot(BiasNormal, LightRay.Direction) < 0.0)
            {
                BiasNormal = -BiasNormal;
            }
            ApplyPositionBias(LightRay, BiasNormal, MaxNormalBias);

            // Trace visibility ray
            uint NeeRayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
            const uint NeeInstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;

#if !ENABLE_TWO_SIDED_GEOMETRY
            NeeRayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
#endif

            FMinimalPayload NeePayload = TraceVisibilityRay(
                TLAS,
                NeeRayFlags,
                NeeInstanceInclusionMask,
                PixelCoord,
                LightRay);

            // No hit indicates successful next-event connection
            if (NeePayload.IsHit())
            {
                HitDistance += NeePayload.HitT;
                HitCount += 1.0;
            }
		    else
            {
                // Evaluate material
                float3 MaterialThroughput;
                float MaterialEvalPdf = 0.0;
#if USE_PATHTRACING_MATERIALS
                float3 MaterialWeight = 0;
                EvalMaterial(Ray.Direction, LightRay.Direction, Payload, MaterialWeight, MaterialEvalPdf);
                MaterialThroughput = MaterialWeight * MaterialEvalPdf;
#else
                half3 N = WorldNormal;
                half3 V = -Ray.Direction;
                half3 L = LightRay.Direction;
                float NoL = saturate(dot(N, L));
                FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
                FDirectLighting LightingSample = EvaluateBxDF(GBufferData, N, V, L, NoL, ShadowTerms);
                MaterialThroughput = LightingSample.Diffuse;
                if (bTransmission)
                {
                    MaterialThroughput += LightingSample.Transmission;
                }
                MaterialEvalPdf = 1.0;
#endif

                // Record the contribution
                float3 ExitantRadianceSample = LightRadianceOverPdf * MaterialThroughput;
                // Tonemap for firefly suppression
                if (UseFireflySuppression)
                {
                    ExitantRadianceSample *= rcp(1.0 + Luminance(ExitantRadianceSample));
                }

                Irradiance += isfinite(ExitantRadianceSample) ? ExitantRadianceSample : 0.0;
            }
        }
    }

    if (SamplesPerPixel > 0)
	{
		Irradiance /= SamplesPerPixel;
		// Tonemap inversion for firefly suppression
		if (UseFireflySuppression)
		{
			Irradiance *= rcp(1 - Luminance(Irradiance));
		}
        float SamplesPerPixelInv = rcp(SamplesPerPixel);
        AmbientOcclusion = HitCount * SamplesPerPixelInv;
	}

	if (HitCount > 0.0)
	{
		HitDistance /= HitCount;
	}
	else
	{
		HitDistance = -1.0;
	}

	AmbientOcclusion = saturate(AmbientOcclusion);

#if USE_PREEXPOSURE
	Irradiance *= View.PreExposure;
#endif

	Irradiance = ClampToHalfFloatRange(Irradiance);
	RWMeshLightIllumianceUAV[DispatchThreadId] = float4(Irradiance, AmbientOcclusion);
	RWMeshLightRayDistanceUAV[DispatchThreadId] = float2(HitDistance, SamplesPerPixel);
}