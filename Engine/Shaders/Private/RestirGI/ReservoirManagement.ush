#pragma once

// Code for managing reads/writes to reservoirs

struct RTXGI_PackedReservoir
{
	// Internal compressed GI sample data
	uint4 VisPos;
	uint4 SamPos;

	uint4 	data1;
	uint4   data2;
};

RWStructuredBuffer<RTXGI_PackedReservoir> RWGIReservoirUAV;
uint3 ReservoirBufferDim;

RWStructuredBuffer<RTXGI_PackedReservoir> RWGIReservoirHistoryUAV;
StructuredBuffer<RTXGI_PackedReservoir> GIReservoirHistory;
uint3 ReservoirHistoryBufferDim;

uint ComputeReservoirAddress(int2 PixelCoord, int Slice, uint3 BufferDim)
{
	static const uint TileSize = 4;
	const uint RowStride = (BufferDim.x / TileSize) * TileSize * TileSize;

	int2 Tile = PixelCoord / TileSize;
	int2 TileCoord = PixelCoord % TileSize;

	uint Address = Slice * BufferDim.x * BufferDim.y;
	Address += Tile.y * RowStride;
	Address += Tile.x * TileSize * TileSize;
	Address += TileCoord.y * TileSize + TileCoord.x;

	return Address;
}

RTXGI_PackedReservoir ReadReservoirData(int2 PixelCoord, int Slice)
{
	uint Address = ComputeReservoirAddress(PixelCoord, Slice, ReservoirBufferDim) ;
	return RWGIReservoirUAV[Address];
}

RTXGI_PackedReservoir ReadReservoirHistoryData(int2 PixelCoord, int Slice)
{
	uint Address = ComputeReservoirAddress(PixelCoord, Slice, ReservoirHistoryBufferDim) ;
	return GIReservoirHistory[Address];
}

void WriteReservoirData(int2 PixelCoord, int Slice,in RTXGI_PackedReservoir Value)
{
	uint Address = ComputeReservoirAddress(PixelCoord, Slice, ReservoirBufferDim) ;
	RWGIReservoirUAV[Address] = Value; //0
}

void WriteReservoirHistoryData(int2 PixelCoord, int Slice,in RTXGI_PackedReservoir Value)
{
	uint Address = ComputeReservoirAddress(PixelCoord, Slice, ReservoirHistoryBufferDim) ;

	RWGIReservoirHistoryUAV[Address] = Value;
}

struct RTXGI_SampleRef
{
	// Internal compressed GI sample data
	uint4 VisPos;
	uint4 SamPos;

	float3 Li;
	uint   Valid;

	float3 GetVisPosition()
	{
		return asfloat( VisPos.xyz);
	}

	float3 GetVisNormal()
	{
		uint normal_w = VisPos.w;
		float3 normal;
		normal.x = (float)((normal_w >> 0u) & 0xFF) / 255.0 * 2 - 1;
		normal.y = (float)((normal_w >> 8u) & 0xFF) / 255.0 * 2 - 1;
		normal.z = (float)((normal_w >> 16u) & 0xFF) / 255.0 * 2 - 1;

		return normal;
	}

	float3 GetSamPosition()
	{
		return asfloat( SamPos.xyz);
	}

	float3 GetSamNormal()
	{
		uint normal_w = SamPos.w;
		float3 normal;
		normal.x = (float)((normal_w >> 0u) & 0xFF) / 255.0 * 2 - 1;
		normal.y = (float)((normal_w >> 8u) & 0xFF) / 255.0 * 2 - 1;
		normal.z = (float)((normal_w >> 16u) & 0xFF) / 255.0 * 2 - 1;

		return normal;
	}

	void SetVisPoint(float3 normal, float3 position)
	{
		uint normal_extra = 0; // reset only the normals
		normal_extra |= (uint)((normal.x * 0.5f + 0.5f) * 255.0f) << 0;
		normal_extra |= (uint)((normal.y * 0.5f + 0.5f) * 255.0f) << 8;
		normal_extra |= (uint)((normal.z * 0.5f + 0.5f) * 255.0f) << 16;

		VisPos.xyz = asuint(position);
		VisPos.w = normal_extra;
		Valid = 1;
	}

	void SetSamPoint(float3 normal, float3 position)
	{
		uint normal_extra = 0;
		normal_extra |= (uint)((normal.x * 0.5f + 0.5f) * 255.0f) << 0;
		normal_extra |= (uint)((normal.y * 0.5f + 0.5f) * 255.0f) << 8;
		normal_extra |= (uint)((normal.z * 0.5f + 0.5f) * 255.0f) << 16;

		SamPos.xyz = asuint(position.xyz);
		SamPos.w = normal_extra;

		Valid = 1;
	}

	bool IsValid()
	{
		return Valid > 0;
	}

	static RTXGI_SampleRef Invalid()
	{
		RTXGI_SampleRef s = (RTXGI_SampleRef)0;
		s.Valid = 0;
		s.VisPos = 0;
		s.SamPos = 0;
		s.Li = 0;
		return s;
	}

	static RTXGI_SampleRef Create(float3 samPos, float3 samNormal, float3 visPos, float3 visNormal)
	{
		RTXGI_SampleRef s;
		s.SetVisPoint(visPos, visNormal);
		s.SetSamPoint(samPos, samNormal);
		s.Valid = 1;
		return s;
	}
};

// Use 24-bit unsigned float to enable extra precision and keep the reservior in a single 128-bit quantity
#define CUSTOM_FLOAT 1

struct RTXGI_Reservoir
{
	static const uint MaxM = 0xffff;

	RTXGI_SampleRef sampleRef;
	float weightSum;
	float targetPdf;
	uint M;

	static RTXGI_Reservoir Empty()
	{
		RTXGI_Reservoir s;
		s.sampleRef = RTXGI_SampleRef::Invalid();
		s.targetPdf = 0;
		s.weightSum = 0;
		s.M = 0;
		return s;
	}

	static RTXGI_Reservoir Load(RTXGI_PackedReservoir data)
	{
		RTXGI_Reservoir res;
		res.sampleRef.VisPos = data.VisPos;
		res.sampleRef.SamPos = data.SamPos;
		res.sampleRef.Li = asfloat(data.data1.xyz);
		res.sampleRef.Valid = data.data1.w;
#if !CUSTOM_FLOAT
		res.weightSum = f16tof32(data.data2.z);
		res.targetPdf = f16tof32(data.data2.z >> 16);
		res.M = data.data2.w;
#else
		res.M = data.data2.w & 0xff;
		res.M |= (data.data2.z & 0xff) << 8;

		// unsigned 24 bit floats
		uint weightSum = (data.data2.z & 0xffffff00);
		uint targetPdf = (data.data2.w & 0xffffff00);
		res.weightSum = asfloat(weightSum >> 1);
		res.targetPdf = asfloat(targetPdf >> 1);

#endif

		// Discard reservoirs that have Inf/NaN
		if (isinf(res.weightSum) || isnan(res.weightSum)) {
			res = Empty();
		}

		return res;
	}

	RTXGI_PackedReservoir Store()
	{
		RTXGI_PackedReservoir data;
		data.VisPos = sampleRef.VisPos;
		data.SamPos = sampleRef.SamPos;
		data.data1.xyz = asuint(sampleRef.Li);
		data.data1.w = sampleRef.Valid;
		data.data2 = 0;
#if !CUSTOM_FLOAT
		data.data2.w = M;
		data.data2.z = f32tof16(weightSum) | (f32tof16(targetPdf) << 16);
#else

		const float RoundConst = 1.0f / float(1 << 18); // 1/(2^18) is the first bit unrepresented by the custom float)
		float RoundedWeight = weightSum + weightSum * RoundConst;
		float RoundedPdf = targetPdf + targetPdf * RoundConst;

		//remove sign as values are guaranteed positive
		uint uWeightSum = asuint(max(0.0, RoundedWeight)) << 1;
		uint uTargetPdf = asuint(max(0.0, RoundedPdf)) << 1;

		//chop to 24 bits
		uWeightSum = uWeightSum & 0xffffff00;
		uTargetPdf = uTargetPdf & 0xffffff00;

		//clamp M
		M = min(M, MaxM);

		// pack M to bottom bits
		data.data2.z = (uWeightSum) | ((M >> 8) & 0xff);
		data.data2.w = (uTargetPdf) | (M & 0xff);
#endif

		return data;
	}

	void FinalizeResampling(float normalizationNumerator, float normalizationDenominator)
	{
		float denominator = targetPdf * normalizationDenominator;

		weightSum = (denominator == 0.0) ? 0.0 : (weightSum * normalizationNumerator) / denominator;
	}

	// Adds a new, non-reservoir GI sample into this reservoir.
	// Algorithm (3) from the ReSTIR paper, Streaming RIS using weighted reservoir sampling.
	bool StreamSample(RTXGI_SampleRef newSampleRef, float random, float newTargetPdf, float invSourcePdf)
	{
		// What's the current weight
		float risWeight = newTargetPdf * invSourcePdf;

		// Add one sample to the counter
		M += 1;

		// Update the weight sum
		weightSum += risWeight;

		// Decide if we will randomly pick this sample
		bool selectSample = (random * weightSum <= risWeight);

		// If we did select this sample, update the relevant data.
		// New samples don't have visibility or age information, we can skip that.
		if (selectSample)
		{
			sampleRef = newSampleRef;
			targetPdf = newTargetPdf;
		}

		return selectSample;
	}

	// Adds a reservoir with one sample into this reservoir.
	// Algorithm (4) from the ReSTIR paper, Combining the streams of multiple reservoirs.
	// Normalization - Equation (6) - is postponed until all reservoirs are combined.
	bool CombineReservoirs(RTXGI_Reservoir newReservoir, float random, float newTargetPdf)
	{
		// What's the current weight (times any prior-step RIS normalization factor)
		float risWeight = newTargetPdf * newReservoir.weightSum * newReservoir.M;

		// Our *effective* candidate pool is the sum of our candidates plus those of our neighbors
		M += newReservoir.M;

		// Update the weight sum
		weightSum += risWeight;

		// Decide if we will randomly pick this sample
		bool selectSample = (random * weightSum <= risWeight);

		// If we did select this sample, update the relevant data
		if (selectSample)
		{
			sampleRef = newReservoir.sampleRef;
			targetPdf = newTargetPdf;
		}

		return selectSample;
	}
};
