#define USE_IES_TERM 0 // this shader doesn't bind the IES atlas, so disable the IES term from path tracer lights
#include "../Common.ush"

#include "../RectLight.ush"
//#include "../MonteCarlo.ush"
#include "../DeferredShadingCommon.ush"
#include "../ShadingModels.ush"
#include "../SceneTextureParameters.ush"
#include "../RayTracing/RayTracingCommon.ush"

#include "../RayTracing/RayTracingDeferredShadingCommon.ush"
#include "../RayTracing/RayTracingHitGroupCommon.ush"

#include "../PathTracing/Material/PathTracingMaterialSampling.ush"
#include "../PathTracing/Utilities/PathTracingRandomSequence.ush"
#include "../PathTracing/Light/PathTracingLightSampling.ush"

#include "ProbeLookup.ush"
RaytracingAccelerationStructure TLAS;

uint  SamplesPerPixel;
uint UpscaleFactor;
float MaxRayDistanceForGI;
float MaxRayDistanceForAO;
float MaxShadowDistance;
float NextEventEstimationSamples;
float DiffuseThreshold;
uint EvalSkyLight;
uint UseRussianRoulette;
uint UseFireflySuppression;
float MaxNormalBias;
uint AccumulateEmissive;

RWTexture2D<float4> RWDebugGIUAV;
RWTexture2D<float2> RWGIRayDistanceUAV;

#if USE_SURFEL
#include "../SurfelGI/SurfelCommon.ush"

RWByteAddressBuffer SurfelMetaBuf;
RWByteAddressBuffer SurfelGridMetaBuf;

RWStructuredBuffer<uint> SurfelLifeBuf;
RWStructuredBuffer<uint> SurfelPoolBuf;
RWStructuredBuffer<SurfelVertexPacked> SurfelRePositionBuf;
RWStructuredBuffer<uint> SurfelRePositionCountBuf;
RWStructuredBuffer<SurfelVertexPacked> SurfelVertexBuf;
RWStructuredBuffer<float4> SurfelIrradianceBuf;
RWStructuredBuffer<uint> SurfelEntryCellBuf;

#include "../SurfelGI/SurfelLookUp.ush"
#endif
void GenerateCosineNormalRay(
	float3 WorldPosition,
	float3 WorldNormal,
	float2 RandSample,
	out float3 RayOrigin,
	out float3 RayDirection,
	out float RayTMin,
	out float RayTMax,
	out float RayPdf
)
{
	// Perform cosine-hemispherical sampling and convert to world-space
	float4 Direction_Tangent = CosineSampleHemisphere(RandSample);
	float3 Direction_World = TangentToWorld(Direction_Tangent.xyz, WorldNormal);

	RayOrigin = WorldPosition;
	RayDirection = Direction_World;
	RayTMin = 0.01;
	RayTMax = max(MaxRayDistanceForGI, MaxRayDistanceForAO);
	RayPdf = Direction_Tangent.w;
}

RAY_TRACING_ENTRY_RAYGEN(GlobalIlluminationRGS)
{
    uint2 DispatchThreadId = DispatchRaysIndex().xy + uint2(View.ViewRectMin.xy);
	RWDebugGIUAV[DispatchThreadId] = 0.0;
	RWGIRayDistanceUAV[DispatchThreadId] = float2(-1.0, 0.0);

	uint2 PixelCoord = GetPixelCoord(DispatchThreadId, UpscaleFactor);
	uint LinearIndex = CalcLinearIndex(PixelCoord);

	bool IsUnidirectionalEnabled = false;

	// Get G-Buffer surface data
	float2 InvBufferSize = View.BufferSizeAndInvSize.zw;
	float2 UV = (float2(PixelCoord) + 0.5) * InvBufferSize;

#if 0
	FGBufferData GBufferData = GetGBufferDataFromSceneTextures(UV);
#else
	//#dxr-todo: workaround for flickering. UE-87281
	FGBufferData GBufferData = GetGBufferDataFromSceneTexturesLoad(PixelCoord);
#endif
	// Remap DiffuseColor when using SubsurfaceProfile (GBuffer decoding replaces with 100% albedo)
	if (UseSubsurfaceProfile(GBufferData.ShadingModelID))
	{
		GBufferData.DiffuseColor = GBufferData.StoredBaseColor;
	}
	float DeviceZ = SceneDepthTexture.Load(int3(PixelCoord, 0)).r;
	float3 WorldPosition;
	float3 CameraDirection;
	ReconstructWorldPositionAndCameraDirectionFromDeviceZ(PixelCoord, DeviceZ, WorldPosition, CameraDirection);
	float3 WorldNormal = GBufferData.WorldNormal;
	uint ShadingModelID = GBufferData.ShadingModelID;
	if (ShadingModelID == SHADINGMODELID_UNLIT)
	{
		return;
	}

	// Diffuse color rejection threshold
	float3 DiffuseColor = GBufferData.DiffuseColor;
	if (Luminance(DiffuseColor) < DiffuseThreshold)
	{
		return;
	}

  	float3 Irradiance = 0;
	float HitDistance = 0.0;
	float HitCount = 0.0;
	float AmbientOcclusion = 0.0;

    for (uint SampleIndex = 0; SampleIndex < SamplesPerPixel; ++SampleIndex)
    {
      	RandomSequence RandSequence;
		RandomSequence_Initialize(RandSequence, PixelCoord, SampleIndex, View.StateFrameIndex, SamplesPerPixel);
        float3 RandSample = RandomSequence_GenerateSample3D(RandSequence);
        float3 RayThroughput = 1.0;
 	    if (UseRussianRoulette)
		{
			float RRSample = RandSample.x;
			float ProbabilityOfSuccess = Luminance(DiffuseColor);
			float ProbabilityOfTermination = 1.0 - ProbabilityOfSuccess;
			if (RRSample < ProbabilityOfTermination) continue;
			RayThroughput /= ProbabilityOfSuccess;
		}

		// Initialize ray
		RayDesc Ray;
		float RayPdf = 1.0;
        
        GenerateCosineNormalRay(WorldPosition, WorldNormal, RandSample.yz, Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax, RayPdf);
		half3 N = WorldNormal;
		half3 V = -CameraDirection;
		half3 L = Ray.Direction;
		float NoL = saturate(dot(N, L));
		FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
		FDirectLighting LightingSample = EvaluateBxDF(GBufferData, N, V, L, NoL, ShadowTerms);
		RayThroughput *= LightingSample.Diffuse / DiffuseColor;

        Ray.TMax = max(MaxRayDistanceForGI, MaxRayDistanceForAO);
		ApplyCameraRelativeDepthBias(Ray, PixelCoord, DeviceZ, WorldNormal, MaxNormalBias);
		

        FarRadianceFieldQuery FieldQuery = FarRadianceFieldQuery::FromRay(Ray.Origin, Ray.Direction);
        FieldQuery.QueryNormal = WorldNormal;
        FieldQuery.InterpolationURand = RandomSequence_GenerateSample3D(RandSequence);
        FarRadianceField Field = FieldQuery.Query();
        if (Field.IsHit()) 
        {
            Ray.TMax = Field.ProbeHitT;
            // Ray.TMax = 0.01;
        }

		float MaterialPdf = 0.0;
		uint Bounce = 0;
		while (Bounce < 1)
        {
            // Cast ray
            uint RayFlags = 0;
            const uint InstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;
            const bool bEnableSkyLightContribution = true;
            const bool bIgnoreTranslucentMaterials = false;

#if !ENABLE_TWO_SIDED_GEOMETRY
			RayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
#endif

            FRayCone RayCone = (FRayCone)0;
            FMaterialClosestHitPayload Payload = TraceMaterialRay(
                TLAS,
                RayFlags,
                InstanceInclusionMask,
                Ray,
                RayCone,
                PixelCoord,
                bEnableSkyLightContribution,
                bIgnoreTranslucentMaterials);

            // Environment hit
            if (Payload.IsMiss())
            {
                if (Field.IsHit()) 
                {
                    Irradiance += Field.Radiance * Field.InvPdf;
                    HitDistance += Field.ProbeHitT;
                    HitCount += 1.0;
                    if (Field.ProbeHitT < MaxRayDistanceForAO)
                    {
                        AmbientOcclusion += 1.0;
                    }
                }
                else 
                {
                    // Optional multi-bounce SkyLight contribution
                   // if (EvalSkyLight && Bounce > 0)
                    {
                        uint SkyLightId = 0;
                        RayDesc LightRay = Ray;
                        LightRay.TMax = POSITIVE_INFINITY;
                        float3 EnvironmentRadiance = SkyLight_TraceLight(Ray, SkyLightId).Radiance;
                        Irradiance += EnvironmentRadiance * RayThroughput / RayPdf;
                    }
                }
                break;
            }

           	if (Bounce == 0)
			{
				HitDistance += Payload.HitT;
				HitCount += 1.0;
				if (Payload.HitT < MaxRayDistanceForAO)
				{
					AmbientOcclusion += 1.0;
				}
			}
            if (Payload.HitT > MaxRayDistanceForGI) break;

            // Update intersection
            Ray.Origin += Ray.Direction * Payload.HitT;

            // Create faux GBuffer to use with EvaluateBxDF
            FGBufferData GBufferData = (FGBufferData)0;
            GBufferData.Depth = 1.f; // Do not use depth
            GBufferData.WorldNormal = Payload.WorldNormal;
            GBufferData.BaseColor = Payload.BaseColor;
            GBufferData.CustomData = Payload.CustomData;
            GBufferData.GBufferAO = Payload.GBufferAO;
            GBufferData.IndirectIrradiance = (Payload.IndirectIrradiance.x + Payload.IndirectIrradiance.y + Payload.IndirectIrradiance.z) / 3.f;
            GBufferData.SpecularColor = Payload.SpecularColor;
            GBufferData.DiffuseColor = Payload.DiffuseColor;			
            GBufferData.Metallic = Payload.Metallic;
            GBufferData.Specular = Payload.Specular;
            GBufferData.Roughness = Payload.Roughness;
            GBufferData.ShadingModelID = Payload.ShadingModelID;
            GBufferData.CustomData = Payload.CustomData;


        #if !MESH_LIGHT_SAMPLING
            // if (AccumulateEmissive)
            // {
            // 	Irradiance += Payload.Radiance * RayThroughput / RayPdf;
            // }
        #endif

        //     float SplitFactor = 1.0 / NextEventEstimationSamples;
        //     for (uint NeeID = 0; NeeID < NextEventEstimationSamples; ++NeeID)
        //     {
        //         // Light selection
        //         int LightId;
        //         float3 LightRadianceOverPdf = 0;
        //         float NeePdf = 0.0;

        //         float3 RandSample3 = RandomSequence_GenerateSample3D(RandSequence);
        //         RayDesc LightRay;

        //         bool bLit = SampleLight(RandSample3,
        //                 Ray.Origin,
        //                 Payload.WorldNormal,
        //                 Payload.PrimitiveLightingChannelMask,
        //                 ENABLE_TRANSMISSION,
        //                 LightId,
        //                 LightRay.Direction,
        //                 LightRay.TMax,
        //                 LightRadianceOverPdf,
        //                 NeePdf);

        //         if (bLit)
        //         {
        //             LightRay.Origin = Ray.Origin;
        //             LightRay.TMin = 0;
        //             LightRay.TMax = min(LightRay.TMax, MaxShadowDistance);
        //             bool bTransmission = HasTransmission(LightId);
        //             float3 BiasNormal = Payload.WorldNormal;
        //             if (bTransmission && dot(BiasNormal, LightRay.Direction) < 0.0)
        //             {
        //                 BiasNormal = -BiasNormal;
        //             }
        //             ApplyPositionBias(LightRay, BiasNormal, MaxNormalBias);

        //             // Trace visibility ray
        //             uint NeeRayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
        //             const uint NeeInstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;

        // #if !ENABLE_TWO_SIDED_GEOMETRY
        //             NeeRayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
        // #endif

        //             FMinimalPayload NeePayload = TraceVisibilityRay(
        //                 TLAS,
        //                 NeeRayFlags,
        //                 NeeInstanceInclusionMask,
        //                 PixelCoord,
        //                 LightRay);

        //             // No hit indicates successful next-event connection
        //             if (NeePayload.IsMiss())
        //             {
        //                 // Evaluate material
        //                 float3 MaterialThroughput;

        //                 half3 N = Payload.WorldNormal;
        //                 half3 V = -Ray.Direction;
        //                 half3 L = LightRay.Direction;
        //                 float NoL = saturate(dot(N, L));
        //                 FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
        //                 FDirectLighting LightingSample = EvaluateBxDF(GBufferData, N, V, L, NoL, ShadowTerms);
        //                 MaterialThroughput = LightingSample.Diffuse + LightingSample.Specular;
        //                 if (bTransmission)
        //                 {
        //                     MaterialThroughput += LightingSample.Transmission;
        //                 }

        //                 // Record the contribution
        //                 float3 ExitantRadianceSample = LightRadianceOverPdf * MaterialThroughput * RayThroughput * SplitFactor / RayPdf;

        //                 // Tonemap for firefly suppression
        //                 if (UseFireflySuppression)
        //                 {
        //                     ExitantRadianceSample *= rcp(1.0 + Luminance(ExitantRadianceSample));
        //                 }

        //                Irradiance += isfinite(ExitantRadianceSample) ? ExitantRadianceSample : 0.0;
        //                 // Irradiance += float3(1.0,0.0,0.0);
        //             }
        //         }
        //     }
            #if USE_SURFEL
            {
                float3 surfelLighting = float3(0.0f, 0.0f, 0.0f);
                float3 albedo = GBufferData.DiffuseColor;
                // Perfectly diffuse reflectors don't exist in the real world. Limit the BRDF
                // albedo to a maximum value to account for the energy loss at each bounce.
                float maxAlbedo = 0.9f;

                surfelLighting = GetSurfelGI(Ray.Origin, GBufferData.WorldNormal, 0, RandSequence) * min(albedo, maxAlbedo);
                // float3 surfacePosWS = Ray.Origin + Ray.Direction * Payload.HitT;
                // // don't apply volume lighting outside the volume
                // float3 relPos = abs(surfacePosWS - VolumeProbeOrigin);
                // if ((relPos.x > Volume_Radius.x || relPos.y > Volume_Radius.y || relPos.z > Volume_Radius.z))
                //     surfelLighting = float3(0.0f, 0.0f, 0.0f);
               Irradiance += surfelLighting;
            }
            #endif
            Bounce++;
        }
    }
    
  	if (SamplesPerPixel > 0)
	{
		Irradiance /= SamplesPerPixel;
		// Tonemap inversion for firefly suppression
		if (UseFireflySuppression)
		{
			Irradiance *= rcp(1 - Luminance(Irradiance));
		}

		AmbientOcclusion /= SamplesPerPixel;
	}

	if (HitCount > 0.0)
	{
		HitDistance /= HitCount;
	}
	else
	{
		HitDistance = -1.0;
	}

	AmbientOcclusion = saturate(AmbientOcclusion);

#if USE_PREEXPOSURE
	Irradiance *= View.PreExposure;
#endif

	Irradiance = ClampToHalfFloatRange(Irradiance);

    RWDebugGIUAV[DispatchThreadId] = float4(Irradiance, AmbientOcclusion);
    RWGIRayDistanceUAV[DispatchThreadId] = float2(HitDistance, SamplesPerPixel);
}