/*
Copyright (c) 2021, NVIDIA CORPORATION. All rights reserved.

NVIDIA CORPORATION and its licensors retain all intellectual property
and proprietary rights in and to this software, related documentation
and any modifications thereto. Any use, reproduction, disclosure or
distribution of this software and related documentation without an express
license agreement from NVIDIA CORPORATION is strictly prohibited.
*/

#include "BindingBridge.ush"

NRI_BEGIN_GLOBAL_CONSTANTS
    float4x4 gPrevWorldToClip;
    float4   gFrustumRight;
    float4   gFrustumUp;
    float4   gFrustumForward;
    float4   gPrevFrustumRight;
    float4   gPrevFrustumUp;
    float4   gPrevFrustumForward;
    float3   gPrevCameraPosition;
    float    gJitterDelta;
    float2   gMotionVectorScale;
    uint2    gResolution;
    float2   gInvViewSize;
    float    gUseBicubic;
    float    gSpecularAlpha;
    float    gSpecularResponsiveAlpha;
    float    gSpecularVarianceBoost;
    float    gDiffuseAlpha;
    float    gDiffuseResponsiveAlpha;
    float    gWorldSpaceMotion;
    float    gIsOrtho;
    float    gUnproject;
    float    gNeedHistoryReset;
    float    gDenoisingRange;
    float    gDisocclusionThreshold;
NRI_END_GLOBAL_CONSTANTS

#include "RELAX_Common.ush"


// Inputs
NRI_RESOURCE(Texture2D<float4>, gSpecularIllumination, t, 0, 0);
NRI_RESOURCE(Texture2D<float4>, gDiffuseIllumination, t, 1, 0);
NRI_RESOURCE(Texture2D<float4>, gMotion, t, 2, 0);
NRI_RESOURCE(Texture2D<uint2>, gNormalRoughnessDepth, t, 3, 0);
NRI_RESOURCE(Texture2D<uint2>, gPrevSpecularAndDiffuseIlluminationLogLuv, t, 4, 0);
NRI_RESOURCE(Texture2D<uint2>, gPrevSpecularAndDiffuseIlluminationResponsiveLogLuv, t, 5, 0);
NRI_RESOURCE(Texture2D<float4>, gPrevSpecularIlluminationUnpacked, t, 6, 0);
NRI_RESOURCE(Texture2D<float4>, gPrevDiffuseIlluminationUnpacked, t, 7, 0);
NRI_RESOURCE(Texture2D<float2>, gPrevSpecularAndDiffuse2ndMoments, t, 8, 0);
NRI_RESOURCE(Texture2D<uint2>, gPrevNormalRoughnessDepth, t, 9, 0);
NRI_RESOURCE(Texture2D<float>, gPrevReflectionHitT, t, 10, 0);
NRI_RESOURCE(Texture2D<float2>, gPrevSpecularAndDiffuseHistoryLength, t, 11, 0);

// Outputs
NRI_RESOURCE(RWTexture2D<uint2>, gOutSpecularAndDiffuseIlluminationLogLuv, u, 0, 0);
NRI_RESOURCE(RWTexture2D<uint2>, gOutSpecularAndDiffuseIlluminationResponsiveLogLuv, u, 1, 0);
NRI_RESOURCE(RWTexture2D<float2>, gOutSpecularAndDiffuse2ndMoments, u, 2, 0);
NRI_RESOURCE(RWTexture2D<float>, gOutReflectionHitT, u, 3, 0);
NRI_RESOURCE(RWTexture2D<float2>, gOutSpecularAndDiffuseHistoryLength, u, 4, 0);
NRI_RESOURCE(RWTexture2D<float>, gOutSpecularReprojectionConfidence, u, 5, 0);

// Helper functions
float getJitterRadius(float jitterDelta, float linearZ)
{
    return jitterDelta * gUnproject * (gIsOrtho > 0 ? 1.0 : linearZ);
}

float3 getCurrentWorldPos(int2 pixelPos, float depth)
{
    float2 uv = ((float2)pixelPos + float2(0.5, 0.5)) * gInvViewSize * 2.0 - 1.0;
    return depth * (gFrustumForward.xyz + gFrustumRight.xyz * uv.x - gFrustumUp.xyz * uv.y);
}

float3 getPreviousWorldPos(int2 pixelPos, float depth)
{
    float2 uv = ((float2)pixelPos + float2(0.5, 0.5)) * gInvViewSize * 2.0 - 1.0;
    return depth * (gPrevFrustumForward.xyz + gPrevFrustumRight.xyz * uv.x - gPrevFrustumUp.xyz * uv.y);
}

float2 getRoughnessWeightParams(float roughness0)
{
    float a = 1.0 / (roughness0 * 0.5 * 0.999 + 0.001);
    float b = roughness0 * a;
    return float2(a, b);
}

float getRoughnessWeight(float2 params0, float roughness)
{
    return saturate(1.0 - abs(params0.y - roughness * params0.x));
}

float getSpecularLobeHalfAngle(float roughness)
{
    // Defines a cone angle, where micro-normals are distributed
    float r2 = roughness * roughness;
    float r3 = roughness * r2;
    return 3.141592 * r2 / (1.0 + 0.5*r2 + r3);
}

float getSpecularNormalWeight(float2 params0, float3 n0, float3 n)
{
    // Assuming that "n0" is normalized and "n" is not!
    float cosa = saturate(dot(n0, n));
    float a = acos_approx(cosa);
    a = 1.0 - STL::Math::SmoothStep(0.0, params0.x, a);

    return saturate(1.0 + (a - 1.0) * params0.y);
}

float isReprojectionTapValid(int2 pixelCoord, float currentLinearZ, float3 currentWorldPos, float3 previousWorldPos, float3 currentNormal, float3 previousNormal, float jitterRadius)
{
    // Check whether reprojected pixel is inside of the screen
    if (any(pixelCoord < int2(0, 0)) || any(pixelCoord >= int2(gResolution))) return 0;

    // Check if plane distance is acceptable
    float3 posDiff = currentWorldPos - previousWorldPos;
    float maxDot = max(abs(dot(posDiff, previousNormal)), abs(dot(posDiff, currentNormal)));

    // Reject backfacing history: if angle between current normal and previous normal is larger than 90 deg
    if (dot(currentNormal, previousNormal) < 0.0) return 0;

    return ((maxDot / currentLinearZ) > gDisocclusionThreshold + jitterRadius * 2.0) ? 0.0 : 1.0;
}


float getSpecularAlphaParallaxAdjustment(float roughness, float cosa)
{
    // This is the main parameter - cone angle
    float angle = getSpecularLobeHalfAngle(roughness) + 0.5 * 3.141592 / 180.0; // adding 0.5 deg of slack
    float a = acos_approx(cosa);
    a = STL::Math::SmoothStep(0.0, angle, a);
    return saturate(a);
}


// Returns reprojection search result based on surface motion:
// 1 - reprojection found
// 0 - reprojection not found
//
// Also returns reprojected data from previous frame calculated using filtering based on filters above.
// For better performance, some data is filtered using weighed bilinear instead of bicubic even if all bicubic taps are valid.
int loadSurfaceMotionBasedPrevData(
    int2 pixelPosOnScreen,
    float3 currentWorldPos,
    float3 currentNormal,
	float currentHair,
    float currentLinearZ,
    float currentReflectionHitT,
    out float3 prevSpecularIllum,
    out float3 prevDiffuseIllum,
    out float3 prevSpecularResponsiveIllum,
    out float3 prevDiffuseResponsiveIllum,
    out float2 prevSurfaceMotionBasedSpecularAndDiffuse2ndMoments,
    out float3 prevWorldPos,
    out float  prevReflectionHitT,
    out float2 historyLength)
{
    // Setting default values for output
    prevSpecularIllum = 0;
    prevDiffuseIllum = 0;
    prevSpecularResponsiveIllum = 0;
    prevDiffuseResponsiveIllum = 0;
    prevSurfaceMotionBasedSpecularAndDiffuse2ndMoments = 0;
    prevWorldPos = currentWorldPos;
    prevReflectionHitT = currentReflectionHitT;
    historyLength = 0;

    // Reading motion vector
    float3 motionVector = gMotion[pixelPosOnScreen].xyz * gMotionVectorScale.xyy;

    // Calculating jitter margin radius in world space
    float jitterRadius = getJitterRadius(gJitterDelta, currentLinearZ);

    // Calculating previous pixel position and UV
    float2 pixelUV = (pixelPosOnScreen + 0.5) * gInvViewSize;
    float2 prevPixelUV = STL::Geometry::GetPrevUvFromMotion(pixelUV, currentWorldPos, gPrevWorldToClip, motionVector, gWorldSpaceMotion);
    float2 prevPixelPosOnScreen = prevPixelUV * gResolution;

    // Calculating footprint origin and weights
    int2 bilinearOrigin = int2(floor(prevPixelPosOnScreen - 0.5) + 0.5);
    float2 bilinearWeights = frac(prevPixelPosOnScreen - 0.5);

    // Calculating UV for Gather 
    float2 prevPixelUV4Gather = (bilinearOrigin + 1.0) / gResolution;

    // Checking bicubic footprint (with cut corners) first,
    // remembering bilinear taps validity and worldspace position along the way,
    // for faster weighted bilinear and for calculating previous worldspace position
    // bc - bicubic & bilinear tap,
    // bl - bilinear tap
    //
    // -- bc bc --
    // bc bl bl bc
    // bc bl bl bc
    // -- bc bc --

    float bicubicFootprintValid = 1.0;
    float4 bilinearTapsValid = 0;

    float3 prevNormalInTap;
    float prevRoughnessDontCare;
	float prevHair = 0.0;
    float prevDepthInTap;
    float3 prevWorldPosInTap;
    int2 tapPos;
    int reprojectionTapValid;
    float3 prevWorldPos00, prevWorldPos10, prevWorldPos01, prevWorldPos11;

    // Adjusting worldspace position for disocclusion fix:
    // Applying worldspace motion first,
    motionVector *= gWorldSpaceMotion > 0 ? 1.0 : 0.0;

    // Then taking care of camera motion, because world space is always centered at camera position in NRD
    currentWorldPos += motionVector - gPrevCameraPosition;

    // 1st row
    tapPos = bilinearOrigin + int2(0, -1);
#if !USE_HAIR_AWARE_FILTERING
    UnpackNormalRoughnessDepth(prevNormalInTap, prevRoughnessDontCare, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#else
	UnpackNormalRoughnessHairDepth(prevNormalInTap, prevRoughnessDontCare, prevHair, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#endif
    prevWorldPosInTap = getPreviousWorldPos(tapPos, prevDepthInTap);
    reprojectionTapValid = isReprojectionTapValid(tapPos, currentLinearZ, currentWorldPos, prevWorldPosInTap, currentNormal, prevNormalInTap, jitterRadius) * (prevHair == currentHair);
    bicubicFootprintValid *= reprojectionTapValid;

    tapPos = bilinearOrigin + int2(1, -1);
#if !USE_HAIR_AWARE_FILTERING
	UnpackNormalRoughnessDepth(prevNormalInTap, prevRoughnessDontCare, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#else
	UnpackNormalRoughnessHairDepth(prevNormalInTap, prevRoughnessDontCare, prevHair, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#endif
    prevWorldPosInTap = getPreviousWorldPos(tapPos, prevDepthInTap);
    reprojectionTapValid = isReprojectionTapValid(tapPos, currentLinearZ, currentWorldPos, prevWorldPosInTap, currentNormal, prevNormalInTap, jitterRadius);
    bicubicFootprintValid *= reprojectionTapValid;

    // 2nd row
    tapPos = bilinearOrigin + int2(-1, 0);
#if !USE_HAIR_AWARE_FILTERING
	UnpackNormalRoughnessDepth(prevNormalInTap, prevRoughnessDontCare, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#else
	UnpackNormalRoughnessHairDepth(prevNormalInTap, prevRoughnessDontCare, prevHair, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#endif
	prevWorldPosInTap = getPreviousWorldPos(tapPos, prevDepthInTap);
	reprojectionTapValid = isReprojectionTapValid(tapPos, currentLinearZ, currentWorldPos, prevWorldPosInTap, currentNormal, prevNormalInTap, jitterRadius) * (prevHair == currentHair);
	bicubicFootprintValid *= reprojectionTapValid;

    tapPos = bilinearOrigin + int2(0, 0);
#if !USE_HAIR_AWARE_FILTERING
	UnpackNormalRoughnessDepth(prevNormalInTap, prevRoughnessDontCare, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#else
	UnpackNormalRoughnessHairDepth(prevNormalInTap, prevRoughnessDontCare, prevHair, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#endif
	prevWorldPosInTap = getPreviousWorldPos(tapPos, prevDepthInTap);
	reprojectionTapValid = isReprojectionTapValid(tapPos, currentLinearZ, currentWorldPos, prevWorldPosInTap, currentNormal, prevNormalInTap, jitterRadius) * (prevHair == currentHair);
    bicubicFootprintValid *= reprojectionTapValid;
    bilinearTapsValid.x = reprojectionTapValid ? 1.0 : 0.0;
    prevWorldPos00 = prevWorldPosInTap;

    tapPos = bilinearOrigin + int2(1, 0);
#if !USE_HAIR_AWARE_FILTERING
	UnpackNormalRoughnessDepth(prevNormalInTap, prevRoughnessDontCare, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#else
	UnpackNormalRoughnessHairDepth(prevNormalInTap, prevRoughnessDontCare, prevHair, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#endif
	prevWorldPosInTap = getPreviousWorldPos(tapPos, prevDepthInTap);
	reprojectionTapValid = isReprojectionTapValid(tapPos, currentLinearZ, currentWorldPos, prevWorldPosInTap, currentNormal, prevNormalInTap, jitterRadius) * (prevHair == currentHair);
    bicubicFootprintValid *= reprojectionTapValid;
    bilinearTapsValid.y = reprojectionTapValid ? 1.0 : 0.0;
    prevWorldPos10 = prevWorldPosInTap;

    tapPos = bilinearOrigin + int2(2, 0);
#if !USE_HAIR_AWARE_FILTERING
	UnpackNormalRoughnessDepth(prevNormalInTap, prevRoughnessDontCare, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#else
	UnpackNormalRoughnessHairDepth(prevNormalInTap, prevRoughnessDontCare, prevHair, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#endif
	prevWorldPosInTap = getPreviousWorldPos(tapPos, prevDepthInTap);
	reprojectionTapValid = isReprojectionTapValid(tapPos, currentLinearZ, currentWorldPos, prevWorldPosInTap, currentNormal, prevNormalInTap, jitterRadius) * (prevHair == currentHair);
    bicubicFootprintValid *= reprojectionTapValid;

    // 3rd row
    tapPos = bilinearOrigin + int2(-1, 1);
#if !USE_HAIR_AWARE_FILTERING
	UnpackNormalRoughnessDepth(prevNormalInTap, prevRoughnessDontCare, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#else
	UnpackNormalRoughnessHairDepth(prevNormalInTap, prevRoughnessDontCare, prevHair, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#endif
	prevWorldPosInTap = getPreviousWorldPos(tapPos, prevDepthInTap);
	reprojectionTapValid = isReprojectionTapValid(tapPos, currentLinearZ, currentWorldPos, prevWorldPosInTap, currentNormal, prevNormalInTap, jitterRadius) * (prevHair == currentHair);
    bicubicFootprintValid *= reprojectionTapValid;

    tapPos = bilinearOrigin + int2(0, 1);
#if !USE_HAIR_AWARE_FILTERING
	UnpackNormalRoughnessDepth(prevNormalInTap, prevRoughnessDontCare, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#else
	UnpackNormalRoughnessHairDepth(prevNormalInTap, prevRoughnessDontCare, prevHair, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#endif
	prevWorldPosInTap = getPreviousWorldPos(tapPos, prevDepthInTap);
	reprojectionTapValid = isReprojectionTapValid(tapPos, currentLinearZ, currentWorldPos, prevWorldPosInTap, currentNormal, prevNormalInTap, jitterRadius) * (prevHair == currentHair);
    bicubicFootprintValid *= reprojectionTapValid;
    bilinearTapsValid.z = reprojectionTapValid ? 1.0 : 0.0;
    prevWorldPos01 = prevWorldPosInTap;

    tapPos = bilinearOrigin + int2(1, 1);
#if !USE_HAIR_AWARE_FILTERING
	UnpackNormalRoughnessDepth(prevNormalInTap, prevRoughnessDontCare, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#else
	UnpackNormalRoughnessHairDepth(prevNormalInTap, prevRoughnessDontCare, prevHair, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#endif
	prevWorldPosInTap = getPreviousWorldPos(tapPos, prevDepthInTap);
	reprojectionTapValid = isReprojectionTapValid(tapPos, currentLinearZ, currentWorldPos, prevWorldPosInTap, currentNormal, prevNormalInTap, jitterRadius) * (prevHair == currentHair);
    bicubicFootprintValid *= reprojectionTapValid;
    bilinearTapsValid.w = reprojectionTapValid ? 1.0 : 0.0;
    prevWorldPos11 = prevWorldPosInTap;

    tapPos = bilinearOrigin + int2(2, 1);
#if !USE_HAIR_AWARE_FILTERING
	UnpackNormalRoughnessDepth(prevNormalInTap, prevRoughnessDontCare, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#else
	UnpackNormalRoughnessHairDepth(prevNormalInTap, prevRoughnessDontCare, prevHair, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#endif
	prevWorldPosInTap = getPreviousWorldPos(tapPos, prevDepthInTap);
	reprojectionTapValid = isReprojectionTapValid(tapPos, currentLinearZ, currentWorldPos, prevWorldPosInTap, currentNormal, prevNormalInTap, jitterRadius) * (prevHair == currentHair);
    bicubicFootprintValid *= reprojectionTapValid;

    // 4th row
    tapPos = bilinearOrigin + int2(0, 2);
#if !USE_HAIR_AWARE_FILTERING
	UnpackNormalRoughnessDepth(prevNormalInTap, prevRoughnessDontCare, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#else
	UnpackNormalRoughnessHairDepth(prevNormalInTap, prevRoughnessDontCare, prevHair, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#endif
	prevWorldPosInTap = getPreviousWorldPos(tapPos, prevDepthInTap);
	reprojectionTapValid = isReprojectionTapValid(tapPos, currentLinearZ, currentWorldPos, prevWorldPosInTap, currentNormal, prevNormalInTap, jitterRadius) * (prevHair == currentHair);
    bicubicFootprintValid *= reprojectionTapValid;

    tapPos = bilinearOrigin + int2(1, 2);
#if !USE_HAIR_AWARE_FILTERING
	UnpackNormalRoughnessDepth(prevNormalInTap, prevRoughnessDontCare, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#else
	UnpackNormalRoughnessHairDepth(prevNormalInTap, prevRoughnessDontCare, prevHair, prevDepthInTap, gPrevNormalRoughnessDepth[tapPos]);
#endif
	prevWorldPosInTap = getPreviousWorldPos(tapPos, prevDepthInTap);
	reprojectionTapValid = isReprojectionTapValid(tapPos, currentLinearZ, currentWorldPos, prevWorldPosInTap, currentNormal, prevNormalInTap, jitterRadius) * (prevHair == currentHair);
    bicubicFootprintValid *= reprojectionTapValid;

    // Calculating interpolated binary weight for bilinear taps in advance
    STL::Filtering::Bilinear bilinear;
    bilinear.weights = bilinearWeights;
    float interpolatedBinaryWeight = STL::Filtering::ApplyBilinearFilter(bilinearTapsValid.x, bilinearTapsValid.y, bilinearTapsValid.z, bilinearTapsValid.w, bilinear);
    interpolatedBinaryWeight = max(1e-6, interpolatedBinaryWeight);

    // Applying reprojection filters
    int reprojectionFound = 0;

    if (any(bilinearTapsValid))
    {
        // Trying to apply bicubic filter first
        if (gUseBicubic && (bicubicFootprintValid > 0))
        {
            // Bicubic for illumination and 2nd moments
            prevSpecularIllum =
                max(0, BicubicFloat4(gPrevSpecularIlluminationUnpacked, gLinearClamp, prevPixelPosOnScreen, gInvViewSize).rgb);
            prevDiffuseIllum =
                max(0, BicubicFloat4(gPrevDiffuseIlluminationUnpacked, gLinearClamp, prevPixelPosOnScreen, gInvViewSize).rgb);
            prevSurfaceMotionBasedSpecularAndDiffuse2ndMoments =
                max(0, BicubicFloat2(gPrevSpecularAndDiffuse2ndMoments, gLinearClamp, prevPixelPosOnScreen, gInvViewSize));
        }
        else
        {
            // If no success with the bicubic, then do weighted bilinear
            prevSpecularIllum =
                BilinearWithBinaryWeightsFloat4(gPrevSpecularIlluminationUnpacked, bilinearOrigin, bilinearWeights, bilinearTapsValid, interpolatedBinaryWeight).rgb;
            prevDiffuseIllum =
                BilinearWithBinaryWeightsFloat4(gPrevDiffuseIlluminationUnpacked, bilinearOrigin, bilinearWeights, bilinearTapsValid, interpolatedBinaryWeight).rgb;
            prevSurfaceMotionBasedSpecularAndDiffuse2ndMoments =
                max(0, BilinearWithBinaryWeightsFloat2(gPrevSpecularAndDiffuse2ndMoments, gLinearClamp, prevPixelUV4Gather, bilinearWeights, bilinearTapsValid, interpolatedBinaryWeight));
        }

        // Always weighted Bilinear for responsive illumination
        BilinearWithBinaryWeightsLogLuvX2(prevSpecularResponsiveIllum, prevDiffuseResponsiveIllum, gPrevSpecularAndDiffuseIlluminationResponsiveLogLuv, gLinearClamp, prevPixelUV4Gather, bilinearWeights, bilinearTapsValid, interpolatedBinaryWeight);

        // Calculating previousd worldspace position
        // by applying weighted bilinear to worldspace positions in taps.
        // Also calculating history length by using weighted bilinear
        prevWorldPos =
            BilinearWithBinaryWeightsImmediateFloat3(
                prevWorldPos00, prevWorldPos10, prevWorldPos01, prevWorldPos11,
                bilinearOrigin, bilinearWeights, bilinearTapsValid, interpolatedBinaryWeight);

        historyLength = 255.0 * BilinearWithBinaryWeightsFloat2(gPrevSpecularAndDiffuseHistoryLength, gLinearClamp, prevPixelUV4Gather, bilinearWeights, bilinearTapsValid, interpolatedBinaryWeight);
        prevReflectionHitT = BilinearWithBinaryWeightsFloat(gPrevReflectionHitT, gLinearClamp, prevPixelUV4Gather, bilinearWeights, bilinearTapsValid, interpolatedBinaryWeight);

        reprojectionFound = 1;
    }
	return reprojectionFound;
}

// Returns specular reprojection search result based on virtual motion
int loadVirtualMotionBasedPrevData(
    int2 pixelPosOnScreen,
    float3 currentWorldPos,
    float3 currentNormal,
    float currentLinearZ,
    float currentReflectionHitT,
    float3 currentViewVector,
    float3 prevWorldPos,
    out float3 prevSpecularIllum,
    out float3 prevSpecularResponsiveIllum,
    out float  prevSpecular2ndMoment,
    out float3 prevNormal,
    out float prevRoughness,
    out float prevReflectionHitT)
{
    // Setting default values for output
    prevSpecularIllum = 0;
    prevSpecularResponsiveIllum = 0;
    prevSpecular2ndMoment = 0;
    prevNormal = currentNormal;
    prevRoughness = 0;
    prevReflectionHitT = currentReflectionHitT;

    // Taking care of camera motion, because world space is always centered at camera position in NRD
    prevWorldPos += gPrevCameraPosition;
    currentWorldPos -= gPrevCameraPosition;


    // Calculating previous worldspace virtual position based on reflection hitT
    float3 virtualViewVector = normalize(currentViewVector) * currentReflectionHitT;
    float3 prevVirtualWorldPos = prevWorldPos + virtualViewVector;

    float currentViewVectorLength = length(currentViewVector);
    float currentVirtualZ = currentViewVectorLength + currentReflectionHitT;

    float4 prevVirtualClipPos = mul(gPrevWorldToClip, float4(prevVirtualWorldPos, 1.0));
    prevVirtualClipPos.xy /= prevVirtualClipPos.w;
    float2 prevVirtualUV = prevVirtualClipPos.xy * float2(0.5, -0.5) + float2(0.5, 0.5);
    float2 prevVirtualPixelPosOnScreen = prevVirtualUV * gResolution;

    float jitterRadius = getJitterRadius(gJitterDelta, currentVirtualZ);

    // Calculating footprint origin and weights
    int2 bilinearOrigin = int2(floor(prevVirtualPixelPosOnScreen - 0.5) + 0.5);
    float2 bilinearWeights = frac(prevVirtualPixelPosOnScreen - 0.5);

    // Calculating UV for Gather 
    float2 prevVirtualUV4Gather = (bilinearOrigin + 1.0) / gResolution;

    // Checking bilinear footprint
    float3 prevNormal00, prevNormal10, prevNormal01, prevNormal11;
    float prevRoughness00, prevRoughness10, prevRoughness01, prevRoughness11;
    uint2 tapPos;
    float prevLinearZInTap;
    float3 prevWorldPosInTap;
    float4 bilinearTapsValid;

    uint4 gatherResultRed = gPrevNormalRoughnessDepth.GatherRed(gLinearClamp, prevVirtualUV4Gather);
    uint4 gatherResultGreen = gPrevNormalRoughnessDepth.GatherGreen(gLinearClamp, prevVirtualUV4Gather);

    tapPos = bilinearOrigin + int2(0, 0);
    UnpackNormalRoughnessDepth(prevNormal00, prevRoughness00, prevLinearZInTap, uint2(gatherResultRed.w, gatherResultGreen.w));
    prevWorldPosInTap = getPreviousWorldPos(tapPos, prevLinearZInTap);
    bilinearTapsValid.x = isReprojectionTapValid(tapPos, currentLinearZ, currentWorldPos, prevWorldPosInTap, currentNormal, prevNormal00, jitterRadius);

    tapPos = bilinearOrigin + int2(1, 0);
    UnpackNormalRoughnessDepth(prevNormal10, prevRoughness10, prevLinearZInTap, uint2(gatherResultRed.z, gatherResultGreen.z));
    prevWorldPosInTap = getPreviousWorldPos(tapPos, prevLinearZInTap);
    bilinearTapsValid.y = isReprojectionTapValid(tapPos, currentLinearZ, currentWorldPos, prevWorldPosInTap, currentNormal, prevNormal10, jitterRadius);

    tapPos = bilinearOrigin + int2(0, 1);
    UnpackNormalRoughnessDepth(prevNormal01, prevRoughness01, prevLinearZInTap, uint2(gatherResultRed.x, gatherResultGreen.x));
    prevWorldPosInTap = getPreviousWorldPos(tapPos, prevLinearZInTap);
    bilinearTapsValid.z = isReprojectionTapValid(tapPos, currentLinearZ, currentWorldPos, prevWorldPosInTap, currentNormal, prevNormal01, jitterRadius);

    tapPos = bilinearOrigin + int2(1, 1);
    UnpackNormalRoughnessDepth(prevNormal11, prevRoughness11, prevLinearZInTap, uint2(gatherResultRed.y, gatherResultGreen.y));
    prevWorldPosInTap = getPreviousWorldPos(tapPos, prevLinearZInTap);
    bilinearTapsValid.w = isReprojectionTapValid(tapPos, currentLinearZ, currentWorldPos, prevWorldPosInTap, currentNormal, prevNormal11, jitterRadius);

    // Calculating interpolated binary weight for bilinear taps in advance
    STL::Filtering::Bilinear bilinear;
    bilinear.weights = bilinearWeights;
    float interpolatedBinaryWeight = STL::Filtering::ApplyBilinearFilter(bilinearTapsValid.x, bilinearTapsValid.y, bilinearTapsValid.z, bilinearTapsValid.w, bilinear);
    interpolatedBinaryWeight = max(1e-6, interpolatedBinaryWeight);

    //Applying reprojection
    int reprojectionFound = 0;

    // Weighted bilinear for prev specular data based on virtual motion
    if (any(bilinearTapsValid))
    {
        prevSpecularIllum = BilinearWithBinaryWeightsFloat4(gPrevSpecularIlluminationUnpacked, bilinearOrigin, bilinearWeights, bilinearTapsValid, interpolatedBinaryWeight).rgb;
        float3 diffuseIllumDontCare = 0;
        BilinearWithBinaryWeightsLogLuvX2(prevSpecularResponsiveIllum, diffuseIllumDontCare, gPrevSpecularAndDiffuseIlluminationResponsiveLogLuv, gLinearClamp, prevVirtualUV4Gather, bilinearWeights, bilinearTapsValid, interpolatedBinaryWeight);

        prevSpecular2ndMoment = max(0, BilinearWithBinaryWeightsFloat2(gPrevSpecularAndDiffuse2ndMoments, gLinearClamp, prevVirtualUV4Gather, bilinearWeights, bilinearTapsValid, interpolatedBinaryWeight)).r;
        prevNormal = BilinearWithBinaryWeightsImmediateFloat3(
            prevNormal00, prevNormal10, prevNormal01, prevNormal11,
            bilinearOrigin, bilinearWeights, bilinearTapsValid, interpolatedBinaryWeight);
        prevRoughness = BilinearWithBinaryWeightsImmediateFloat(
            prevRoughness00, prevRoughness10, prevRoughness01, prevRoughness11,
            bilinearOrigin, bilinearWeights, bilinearTapsValid, interpolatedBinaryWeight);

        prevReflectionHitT = BilinearWithBinaryWeightsFloat(gPrevReflectionHitT, gLinearClamp, prevVirtualUV4Gather, bilinearWeights, float4(1.0, 1.0, 1.0, 1.0), 1.0);

        reprojectionFound = 1;
    }
    return reprojectionFound;
}

//
// Main
//

[numthreads(8, 8, 1)]
void main(uint3 dispatchThreadId : SV_DispatchThreadID, uint3 groupThreadId : SV_GroupThreadID, uint3 groupId : SV_GroupID)
{
    if (any(dispatchThreadId.xy >= gResolution)) return;


    int2 ipos = int2(dispatchThreadId.xy);

    // Reading raw noisy specular and diffuse.
    // Specular has noisy HitT in its alpha channel
    float4 specularIllumination = gSpecularIllumination[ipos].rgba;
    float3 diffuseIllumination = gDiffuseIllumination[ipos].rgb;
    specularIllumination.a = max(0.001, min(gDenoisingRange, specularIllumination.a));

    // Reading current GBuffer data
    float3 currentNormal;
    float currentRoughness;
	float currentHair = 0.0;
    float currentLinearZ;
#if !USE_HAIR_AWARE_FILTERING
	UnpackNormalRoughnessDepth(currentNormal, currentRoughness, currentLinearZ, gNormalRoughnessDepth[ipos]);
#else
    UnpackNormalRoughnessHairDepth(currentNormal, currentRoughness, currentHair, currentLinearZ, gNormalRoughnessDepth[ipos]);
#endif

    // Early out if linearZ is beyond denoising range
    [branch]
    if (currentLinearZ > gDenoisingRange)
    {
        return;
    }

    // Calculating average normal in 3x3 area around current pixel
    // TODO: move this to shmem?
    float3 averageNormal = currentNormal;
    float sumW = 1.0;
    for (int i = -1; i <= 1; i++)
    {
        for (int j = -1; j <= 1; j++)
        {
            // Skipping center pixel
            if ((i == 0) && (j == 0)) continue;

            int2 p = ipos + int2(i, j);
            float3 pNormal;
            float pRoughness;
            float pZ;
            UnpackNormalRoughnessDepth(pNormal, pRoughness, pZ, gNormalRoughnessDepth[p]);

            float w = abs(pZ - currentLinearZ) / (min(abs(currentLinearZ), abs(pZ)) + 0.001) < 0.05 ? 1.0 : 0.0;

            averageNormal += pNormal * w;
            sumW += w;
        }
    }
    float invSumW = 1.0 / sumW;
    averageNormal *= invSumW;

    // Calculating modified roughness that takes normal variation in account
    float currentRoughnessModified = STL::Filtering::GetModifiedRoughnessFromNormalVariance(currentRoughness, averageNormal);

    // Computing 2nd moments of luminance
    float specular1stMoment = STL::Color::Luminance(specularIllumination.rgb);
    float specular2ndMoment = specular1stMoment * specular1stMoment;

    float diffuse1stMoment = STL::Color::Luminance(diffuseIllumination.rgb);
    float diffuse2ndMoment = diffuse1stMoment * diffuse1stMoment;

    // Getting current frame worldspace position and view vector for current pixel
    float3 currentWorldPos = getCurrentWorldPos(ipos, currentLinearZ);
    float3 currentViewVector = currentWorldPos;

    // Loading previous data based on surface motion vectors
    float3 prevSurfaceMotionBasedSpecularIllumination;
    float3 prevDiffuseIllumination;
    float3 prevSurfaceMotionBasedSpecularResponsiveIllumination;
    float3 prevDiffuseResponsiveIllumination;
    float2 prevSurfaceMotionBasedSpecularAndDiffuse2ndMoments;
    float  prevSurfaceMotionBasedReflectionHitT;
    float3 prevSurfaceMotionBasedWorldPos;
    float2 historyLength;
    float3 debugOut1;

    int surfaceMotionBasedReprojectionFound = loadSurfaceMotionBasedPrevData(ipos.xy,
        currentWorldPos,
        currentNormal,
		currentHair,
        currentLinearZ,
        specularIllumination.a,
        prevSurfaceMotionBasedSpecularIllumination,
        prevDiffuseIllumination,
        prevSurfaceMotionBasedSpecularResponsiveIllumination,
        prevDiffuseResponsiveIllumination,
        prevSurfaceMotionBasedSpecularAndDiffuse2ndMoments,
        prevSurfaceMotionBasedWorldPos,
        prevSurfaceMotionBasedReflectionHitT,
        historyLength
    );

    // History length is based on surface motion based disocclusion
    historyLength = ceil(historyLength) + 1.0;
    historyLength = min(100.0, historyLength);

    // Handling history reset if needed
    if (gNeedHistoryReset != 0) historyLength = 1.0;

    // This adjusts the alpha for the case where insufficient history is available.
    // It boosts the temporal accumulation to give the samples equal weights in
    // the beginning.
    float specularAlpha = surfaceMotionBasedReprojectionFound ? max(gSpecularAlpha, 1.0 / historyLength.x) : 1.0;
    float specularAlphaResponsive = surfaceMotionBasedReprojectionFound ? max(gSpecularResponsiveAlpha, 1.0 / historyLength.x) : 1.0;

    float diffuseAlpha = surfaceMotionBasedReprojectionFound ? max(gDiffuseAlpha, 1.0 / historyLength.y) : 1.0;
    float diffuseAlphaResponsive = surfaceMotionBasedReprojectionFound ? max(gDiffuseResponsiveAlpha, 1.0 / historyLength.y) : 1.0;

    // Temporal accumulation of reflection HitT will happen later in the shader
    float accumulatedReflectionHitT = prevSurfaceMotionBasedReflectionHitT;

    // Calculating surface motion based previous view vector
    float3 prevSurfaceMotionBasedV = normalize(prevSurfaceMotionBasedWorldPos - gPrevCameraPosition);
    float3 currentV = normalize(currentViewVector);
    float prevSurfaceMotionVDotCurrentV = saturate(dot(prevSurfaceMotionBasedV, currentV));
    float parallaxConfidenceAdjustment = 1.0 - getSpecularAlphaParallaxAdjustment(currentRoughness, prevSurfaceMotionVDotCurrentV);

    // Loading specular data based on virtual motion
    float3 prevVirtualMotionBasedSpecularIllumination;
    float3 prevVirtualMotionBasedSpecularResponsiveIllumination;
    float  prevVirtualMotionBasedSpecular2ndMoment;
    float3 prevVirtualMotionBasedNormal;
    float  prevVirtualMotionBasedRoughness;
    float  prevVirtualMotionBasedReflectionHitT;

    int virtualMotionBasedReprojectionFound = loadVirtualMotionBasedPrevData(ipos.xy,
        currentWorldPos,
        currentNormal,
        currentLinearZ,
        accumulatedReflectionHitT,
        currentViewVector,
        prevSurfaceMotionBasedWorldPos,
        prevVirtualMotionBasedSpecularIllumination,
        prevVirtualMotionBasedSpecularResponsiveIllumination,
        prevVirtualMotionBasedSpecular2ndMoment,
        prevVirtualMotionBasedNormal,
        prevVirtualMotionBasedRoughness,
        prevVirtualMotionBasedReflectionHitT);

    // Estimating confidence of virtual motion based specular reprojection,
    // starting with the fact of finding the valid reprojection
    float virtualMotionBasedReprojectionConfidence = virtualMotionBasedReprojectionFound ? 1.0 : 0.0;

    // Adjusting confidence of virtual motion based specular reprojection
    // based on current reflection HitT vs previous reflection HitT:
    // since the HitT is quite noisy, we'll decrease confidence to 0 if difference is quite large: 1/2x of current hitT + linearZ value.
    float maxDist = max(prevVirtualMotionBasedReflectionHitT, accumulatedReflectionHitT);
    float hitTDisocclusionAdjustment = saturate(2.0*abs(prevVirtualMotionBasedReflectionHitT - accumulatedReflectionHitT) / (maxDist + currentLinearZ));
    virtualMotionBasedReprojectionConfidence *= 1.0 - (0.5 + 0.5*parallaxConfidenceAdjustment) * hitTDisocclusionAdjustment;

    // Adjusting confidence of virtual motion based specular reprojection
    // based on current unmodified roughness vs previous roughness: if roughness changes, we decrease confidence
    float2 roughnessWeightParams = getRoughnessWeightParams(currentRoughness);
    virtualMotionBasedReprojectionConfidence *= getRoughnessWeight(roughnessWeightParams, prevVirtualMotionBasedRoughness);

    // Adjusting confidence of virtual motion based specular reprojection
    // based on current normal vs previous normal, and current roughness:
    // we decrease confidence if reprojected normal falls outside cone defined by current surface roughness.
    float2 normalParams;
    normalParams.x = getSpecularLobeHalfAngle(currentRoughnessModified);
    normalParams.x += 2.5 * 3.141592 / 180.0; // adding 2.5 deg of slack to increase reprojection confidence
    normalParams.y = 1.0;
    virtualMotionBasedReprojectionConfidence *= getSpecularNormalWeight(normalParams, currentNormal, prevVirtualMotionBasedNormal);

    // Adjusting accumulation factors for virtual motion based specular
    float specularAlphaVirtualMotionBased = lerp(1.0, specularAlpha, virtualMotionBasedReprojectionConfidence);
    float specularAlphaResponsiveVirtualMotionBased = lerp(1.0, specularAlphaResponsive, virtualMotionBasedReprojectionConfidence);

    // Accumulating using virtual motion based specular reprojection
    float3 virtualMotionBasedSpecularIllumination = lerp(prevVirtualMotionBasedSpecularIllumination.rgb, specularIllumination.rgb, specularAlphaVirtualMotionBased);
    float3 virtualMotionBasedSpecularResponsiveIllumination = lerp(prevVirtualMotionBasedSpecularResponsiveIllumination.rgb, specularIllumination.rgb, specularAlphaResponsiveVirtualMotionBased);
    float  virtualMotionBasedSpecular2ndMoment = lerp(prevVirtualMotionBasedSpecular2ndMoment, specular2ndMoment, specularAlphaVirtualMotionBased);

    // Estimating confidence of surface motion based specular reprojection,
    // starting with the fact of finding the valid reprojection
    float surfaceMotionBasedReprojectionConfidence = surfaceMotionBasedReprojectionFound ? 1.0 : 0.0;

    // Adjusting confidence of surface motion based specular reprojection
    // based on current roughness vs previous roughness for virtual motion: if roughness changes, we decrease confidence,
    // but not much, by 75% only
    surfaceMotionBasedReprojectionConfidence *= 0.25 + 0.75*getRoughnessWeight(roughnessWeightParams, prevVirtualMotionBasedRoughness);

    // Adjusting confidence of surface motion based specular reprojection
    // based on current view vector vs previous view vector and current roughness
    surfaceMotionBasedReprojectionConfidence *= parallaxConfidenceAdjustment;

    // Adjusting accumulation factors for surface motion based specular
    float specularAlphaSurfaceMotionBased = lerp(1.0, specularAlpha, surfaceMotionBasedReprojectionConfidence);
    float specularAlphaResponsiveSurfaceMotionBased = lerp(1.0, specularAlphaResponsive, surfaceMotionBasedReprojectionConfidence);

    // Accumulating using surface motion based specular reprojection
    float3 surfaceMotionBasedSpecularIllumination = lerp(prevSurfaceMotionBasedSpecularIllumination.rgb, specularIllumination.rgb, specularAlphaSurfaceMotionBased);
    float3 surfaceMotionBasedSpecularResponsiveIllumination = lerp(prevSurfaceMotionBasedSpecularResponsiveIllumination.rgb, specularIllumination.rgb, specularAlphaResponsiveSurfaceMotionBased);
    float  surfaceMotionBasedSpecular2ndMoment = lerp(prevSurfaceMotionBasedSpecularAndDiffuse2ndMoments.r, specular2ndMoment, specularAlphaSurfaceMotionBased);

    // Now weighing between virtual and surface motion based specular reprojection
    float virtualVsSurfaceWeight = virtualMotionBasedReprojectionConfidence;

    // Adjusting based on current roughness: virtual motion is perfectly valid for perfect mirrors only
    float dominantDirectionAdjustment = STL::ImportanceSampling::GetSpecularDominantDirection(currentNormal, currentV, currentRoughnessModified).w;
    virtualVsSurfaceWeight *= dominantDirectionAdjustment;

    // We'll add more weight to virtual motion based reprojection if surface motion based reprojection confidence is low due to high parallax
    virtualVsSurfaceWeight = lerp(1.0, virtualVsSurfaceWeight, parallaxConfidenceAdjustment);


    // Calculating overall specular reprojection confidence
    float specularConfidence = lerp(surfaceMotionBasedReprojectionConfidence,
        virtualMotionBasedReprojectionConfidence,
        virtualVsSurfaceWeight);

    // Calculating alpha for reflection hitT accumulation, fastest is 1.0 if reprojection confidence is 0,
    // slowest is 0.1
    float specularHitTAlphaVirtualMotionBased = lerp(1.0, 0.1, virtualMotionBasedReprojectionConfidence);

    // Temporal accumulation of specular hitT
    float virtualMotionBasedAccumulatedReflectionHitT = lerp(prevVirtualMotionBasedReflectionHitT, specularIllumination.a, specularHitTAlphaVirtualMotionBased);
    accumulatedReflectionHitT = virtualMotionBasedAccumulatedReflectionHitT;
    accumulatedReflectionHitT = min(gDenoisingRange, max(0.001, accumulatedReflectionHitT));

    // Temporal accumulation of specular illumination
    float3 accumulatedSpecularIllumination = lerp(surfaceMotionBasedSpecularIllumination,
        virtualMotionBasedSpecularIllumination,
        virtualVsSurfaceWeight);

    float3 accumulatedSpecularIlluminationResponsive = lerp(surfaceMotionBasedSpecularResponsiveIllumination,
        virtualMotionBasedSpecularResponsiveIllumination,
        virtualVsSurfaceWeight);

    // Temporal accumulation of specular moments
    float accumulatedSpecular2ndMoment = lerp(surfaceMotionBasedSpecular2ndMoment,
        virtualMotionBasedSpecular2ndMoment,
        virtualVsSurfaceWeight);

    // Artificially increasing specular variance for pixels with low reprojection confidence
    accumulatedSpecular2ndMoment *= 1.0 + gSpecularVarianceBoost * (1.0 - specularConfidence);
    // If zero specular sample (color = 0), artificially adding variance for pixels with low reprojection confidence
    if (accumulatedSpecular2ndMoment == 0) accumulatedSpecular2ndMoment = gSpecularVarianceBoost * (1.0 - specularConfidence);

    // Temporal accumulation of diffuse 2nd moment
    float accumulatedDiffuse2ndMoment = lerp(prevSurfaceMotionBasedSpecularAndDiffuse2ndMoments.g, diffuse2ndMoment, diffuseAlpha);

    // Temporal accumulation of diffuse illumination
    float3 accumulatedDiffuseIllumination = lerp(prevDiffuseIllumination.rgb, diffuseIllumination.rgb, diffuseAlpha);
    float3 accumulatedDiffuseIlluminationResponsive = lerp(prevDiffuseResponsiveIllumination.rgb, diffuseIllumination.rgb, diffuseAlphaResponsive);

    // Write out the results
    gOutSpecularAndDiffuseIlluminationLogLuv[ipos] = PackSpecularAndDiffuseToLogLuvUint2(accumulatedSpecularIllumination, accumulatedDiffuseIllumination);
    gOutSpecularAndDiffuseIlluminationResponsiveLogLuv[ipos] = PackSpecularAndDiffuseToLogLuvUint2(accumulatedSpecularIlluminationResponsive, accumulatedDiffuseIlluminationResponsive);

    gOutSpecularAndDiffuse2ndMoments[ipos] = float2(accumulatedSpecular2ndMoment, accumulatedDiffuse2ndMoment);

    gOutReflectionHitT[ipos] = accumulatedReflectionHitT;

    gOutSpecularAndDiffuseHistoryLength[ipos] = historyLength / 255.0;

    gOutSpecularReprojectionConfidence[ipos] = specularConfidence;
}
